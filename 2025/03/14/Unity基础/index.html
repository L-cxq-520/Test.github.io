<!DOCTYPE html>
<html lang="zh-Hans">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity基础">
<meta property="og:url" content="https://l-cxq-520.github.io/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="og:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">
<meta property="article:published_time" content="2025-03-14T02:37:43.000Z">
<meta property="article:modified_time" content="2025-04-01T08:39:45.314Z">
<meta property="article:author" content="CXQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://l-cxq-520.github.io/Test.github.io/img/404.jpg">


<title >Unity基础</title>

<!-- Favicon -->

    <link href='/Test.github.io/img/favicon.svg?v=2.1.0-beta.2' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/Test.github.io/img/favicon.svg?v=2.1.0-beta.2' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/Test.github.io/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/Test.github.io/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"l-cxq-520.github.io","author":"CXQ","root":"/Test.github.io/","typed_text":null,"theme_version":"2.1.0-beta.2","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/img/favicon.svg","icon16":"/img/favicon.svg","icon32":"/img/favicon.svg","appleTouchIcon":null,"webmanifest":null,"visibilitychange":false,"hidden":"/failure.ico","showText":"(/≧▽≦/)咦！又好了！","hideText":"(●—●)喔哟，崩溃啦！"},"i18n":{"placeholder":"搜索文章...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）","author":"本文作者：","copyright_link":"本文链接：","copyright_license_title":"版权声明：","copyright_license_content":"本博客所有文章除特别声明外，均默认采用 undefined 许可协议。","copy_success":"复制成功","copy_failure":"复制失败","open_read_mode":"进入阅读模式","exit_read_mode":"退出阅读模式","notice_outdate_message":"距离上次更新已经 undefined 天了, 文章内容可能已经过时。","just":"刚刚","min":"分钟前","hour":"小时前","day":"天前","month":"个月前"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","user_tag":"fas fa-user-alt","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"prismjs","theme":true,"copy":true,"lang":false,"title":"default","height_limit":200}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2025-04-01 16:39:45"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/Test.github.io/css/index.css?v=2.1.0-beta.2" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->
 
<meta name="generator" content="Hexo 7.3.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/Test.github.io/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/Test.github.io/img/favicon.svg">
    
    
        <div class="trm-logo-text">
            Async<span>Theme</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/Test.github.io/" target="">
                    首页
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/Test.github.io/archives2/" target="">
                            archives2
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/Test.github.io/archives/" target="">
                    归档
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/Test.github.io/categories/" target="">
                    分类
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/Test.github.io/tags/" target="">
                    标签
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/Test.github.io/img/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            Unity基础
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/Test.github.io/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2025
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div id="page-sidebar" class="col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/Test.github.io/img/avatar.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        ThemeAsync
    </h5>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com" title="Github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                Residence:
            </div>
            <div class="trm-label trm-label-light">
                Mars
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div id="page-content" class="col-lg-8">
                <div class="trm-content" id="trm-content">
                    <div id="post-info" class="row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            03/14
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            10:37
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            CXQ
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <html><head></head><body><h1 id="Mathf数学计算类常用方法"><a href="#Mathf数学计算类常用方法" class="headerlink" title="Mathf数学计算类常用方法"></a>Mathf数学计算类常用方法</h1><p><code>3D数学-Mathf数学计算公共类</code></p>
<p><strong><font size="4">Mathf和Math:</font></strong></p>
<ul>
<li>Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。</li>
<li>Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。</li>
<li>他们都是提供来用于进行数学相关计算的。</li>
</ul>
<p><strong><font size="4">Mathf和Math的区别:</font></strong></p>
<ul>
<li>Mathf 和 Math中的相关方法几乎一样。</li>
<li>Math - C#自带数学库，提供基本的数学计算方法。</li>
<li>Mathf - Unity专门针对游戏开发增强的数学库，包含了Math中的方法，并添加了一些适用于游戏开发的方法。</li>
</ul>
<p><strong><font size="4">Mathf中的常用方法——(一般计算一次):</font></strong></p>
<p><strong><font size="3">PI常量:获取圆周率π</font></strong> </p>
<ul>
<li>众所周知的”3.14159265358979…”值（只读）。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">   </span><br><span class="line">    print(Mathf.PI);<span class="comment">//3.141593</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Abs静态方法:取绝对值</font></strong></p>
<ul>
<li>返回 f 的绝对值。</li>
</ul>
<blockquote>
<p>绝对值表示一个数不考虑其正负符号的大小。<br>例如, -5 的绝对值是5,而 5 的绝对值也是 5。</p>
</blockquote>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span>()</span></span><br><span class="line">{ </span><br><span class="line">    print(Mathf.Abs(<span class="number">-10</span>));<span class="comment">//10</span></span><br><span class="line">    print(Mathf.Abs(<span class="number">-20</span>));<span class="comment">//20</span></span><br><span class="line">    print(Mathf.Abs(<span class="number">1</span>));<span class="comment">//1</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">CeilToInt静态方法:向上取整</font></strong></p>
<ul>
<li>返回大于或等于 f 的最小整数。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> f = <span class="number">1.3f</span>;</span><br><span class="line">    <span class="built_in">int</span> i = (<span class="built_in">int</span>)f;</span><br><span class="line">    print(i);<span class="comment">//1</span></span><br><span class="line">    print(Mathf.CeilToInt(f));<span class="comment">//2</span></span><br><span class="line">    print(Mathf.CeilToInt(<span class="number">1.00001f</span>));<span class="comment">//2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">FloorToInt静态方法:向下取整</font></strong></p>
<ul>
<li>返回小于或等于 f 的最大整数。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">   </span><br><span class="line">    print(Mathf.FloorToInt(<span class="number">9.6f</span>));<span class="comment">//9</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Clamp静态方法:钳制函数</font></strong></p>
<ul>
<li>在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。</li>
<li>比最小还小，就取最小，比最大还大，就取最大，两者之间，就取本身</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">    print(Mathf.Clamp(<span class="number">10</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//11</span></span><br><span class="line">    print(Mathf.Clamp(<span class="number">21</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//20</span></span><br><span class="line">    print(Mathf.Clamp(<span class="number">15</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//15</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Max静态方法:获取最大值</font></strong></p>
<ul>
<li>返回两个或更多值中的最大值。</li>
<li>内部有一个可变长的参数</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(Mathf.Max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));<span class="comment">//8</span></span><br><span class="line">    print(Mathf.Max(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Min静态方法:获取最小值</font></strong></p>
<ul>
<li>返回两个或更多值中的最小值。</li>
<li>内部有一个可变长的参数</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    </span><br><span class="line">    print(Mathf.Min(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">545</span>, <span class="number">6</span>, <span class="number">1123</span>, <span class="number">123</span>));<span class="comment">//1</span></span><br><span class="line">    print(Mathf.Min(<span class="number">1.1f</span>, <span class="number">0.4f</span>));<span class="comment">//0.4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Pow静态方法:一个数的n次幂</font></strong></p>
<ul>
<li>返回 f 的 p 次幂。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">"一个数的n次方"</span> + Mathf.Pow(<span class="number">4</span>, <span class="number">2</span>));<span class="comment">//16</span></span><br><span class="line">    print(<span class="string">"一个数的n次方"</span> + Mathf.Pow(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">RoundToInt静态方法:四舍五入</font></strong></p>
<ul>
<li>返回舍入为最近整数的/ f /。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"四舍五入"</span>+Mathf.RoundToInt(<span class="number">1.3f</span>));<span class="comment">//1</span></span><br><span class="line">    print(<span class="string">"四舍五入"</span>+Mathf.RoundToInt(<span class="number">1.5f</span>));<span class="comment">//2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Sqrt静态方法:返回一个数的平方根</font></strong></p>
<ul>
<li>返回 f 的平方根。</li>
</ul>
<blockquote>
<p>平方根概念:如果一个数的平方等于另一个数，那么这个数叫做另一个数的平方根或二次方根</p>
</blockquote>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"返回一个数的平方根"</span> + Mathf.Sqrt(<span class="number">4</span>));<span class="comment">//2</span></span><br><span class="line">    print(<span class="string">"返回一个数的平方根"</span> + Mathf.Sqrt(<span class="number">16</span>));<span class="comment">//4</span></span><br><span class="line">    print(<span class="string">"返回一个数的平方根"</span> + Mathf.Sqrt(<span class="number">64</span>));<span class="comment">//8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">IsPowerOfTwo静态方法:判断一个数是否是2的n次方</font></strong></p>
<ul>
<li>如果值是 2的幂,则返回 true</li>
</ul>
<blockquote>
<p>2的幂次方数是指2的n次方的数,其中n为非负整数</p>
</blockquote>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"判断一个数是否是2的n次方"</span> + Mathf.IsPowerOfTwo(<span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line">    print(<span class="string">"判断一个数是否是2的n次方"</span> + Mathf.IsPowerOfTwo(<span class="number">8</span>));<span class="comment">//true</span></span><br><span class="line">    print(<span class="string">"判断一个数是否是2的n次方"</span> + Mathf.IsPowerOfTwo(<span class="number">3</span>));<span class="comment">//false</span></span><br><span class="line">    print(<span class="string">"判断一个数是否是2的n次方"</span> + Mathf.IsPowerOfTwo(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line">    print(<span class="string">"判断一个数是否是2的n次方"</span> + Mathf.IsPowerOfTwo(<span class="number">10</span>));<span class="comment">//false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><font size="3">Sign静态方法:判断正负数</font></strong></p>
<ul>
<li>返回 f 的符号。</li>
<li>正数和0就返回1，负数就返回-1</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"判断正负数"</span> + Mathf.Sign(<span class="number">0</span>));<span class="comment">//1</span></span><br><span class="line">    print(<span class="string">"判断正负数"</span> + Mathf.Sign(<span class="number">10</span>));<span class="comment">//1</span></span><br><span class="line">    print(<span class="string">"判断正负数"</span> + Mathf.Sign(<span class="number">-10</span>));<span class="comment">//-1</span></span><br><span class="line">    print(<span class="string">"判断正负数"</span> + Mathf.Sign(<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">    print(<span class="string">"判断正负数"</span> + Mathf.Sign(<span class="number">-2</span>));<span class="comment">//-1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">Mathf中的常用方法——(一般不停计算)</font></strong></p>
<p><strong><font size="3">Lerp静态方法:插值运算</font></strong></p>
<ul>
<li>用于执行线性插值运算。线性插值是一种基本的数学运算，用于在两个值之间进行平滑的过渡。在游戏开发中，它通常用于在两个状态之间进行平滑过渡，例如在动画中对象的位置、旋转或颜色之间进行插值以实现平滑的动画效果。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Lerp</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b, <span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>a：起始值。</li>
<li>b：目标值。</li>
<li>t：插值参数，通常介于0和1之间。当t为0时，返回起始值a；当t为1时，返回目标值b；当t在0和1之间时，返回起始值a和目标值b之间的插值。</li>
<li>Lerp函数插值的计算方式是通过如下公式来实现的：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a + (b - a) * t</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个公式实际上是线性插值的定义：它从起始值a开始，根据参数t与目标值b之间的差异，按比例插值到目标值。当t为0时，插值结果等于起始值a；当t为1时，插值结果等于目标值b；当t在0和1之间时，插值结果在起始值a和目标值b之间进行平滑过渡。</li>
</ul>
<p><strong><font size="3">插值运算用法一：</font></strong></p>
<ul>
<li>先快后慢，无限接近终点</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置</span></span><br><span class="line">    <span class="comment">//可以理解为 每一帧的时间不变 计算出来的下一帧的位置肯定会更大</span></span><br><span class="line">    <span class="comment">//但是因为下一帧的位置更大 (end - start)就会变小 每一帧的位置移动相比起来就更小了</span></span><br><span class="line">    start = Mathf.Lerp(start, end, Time.deltaTime);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">插值运算用法二：</font></strong></p>
<ul>
<li>匀速接近终点</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果</span></span><br><span class="line">    <span class="comment">//当time大于1时，插值会继续进行，但是Mathf.Lerp方法返回的结果将始终等于end，因为此时参数t等于1，即线性插值的终点。</span></span><br><span class="line">    <span class="comment">//因此，当time大于1时，result将保持等于end，不再发生变化。</span></span><br><span class="line">    <span class="comment">//可以理解为 start和end都不变 只有t在每一帧都在累加一个恒定值</span></span><br><span class="line">    <span class="comment">//比如第一帧t是0.1秒 第二帧就是0.2秒 第五帧t就是0.5秒了</span></span><br><span class="line">    <span class="comment">//这样算出来没帧的结果就是接近线性的</span></span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    result = Mathf.Lerp(start, end, time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.使用线性插值实现一个方块跟随另一个方块移动:</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">场景设置:</font></strong></p>
<ul>
<li>在场景中创建两个方块A和B，目的是让方块A跟随方块B移动。</li>
</ul>
<p><strong><font size="3">创建脚本并编写:</font></strong></p>
<ul>
<li>创建一个脚本，将其挂载到方块A上。在脚本中添加必要的变量，包括要跟随的对象B、移动速度等。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">TestMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">     <span class="comment">//要跟随的对象B</span></span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位置中介</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B当前的位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 bNowPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 startPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匀速运动累加的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> mode = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">切换逻辑:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">TestMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>), <span class="string">"切换模式"</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(mode == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                mode = <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                mode = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">根据不同模式进行移动:</font></strong></p>
<ul>
<li>在Update函数中根据不同的模式进行移动处理。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">TestMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//第一种：先快后慢的形式</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录当前这一帧A的位置</span></span><br><span class="line">            pos = <span class="keyword">this</span>.transform.position;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//传入这一帧A的位置算出下一帧A的位置</span></span><br><span class="line">            pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime * moveSpeed);</span><br><span class="line">            pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime * moveSpeed);</span><br><span class="line">            pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//算出下一帧A的位置赋值给A</span></span><br><span class="line">            <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">2</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//第二种：匀速运动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发现存储的B的位置不等于当前B的位置</span></span><br><span class="line">            <span class="keyword">if</span> (bNowPos != B.transform.position)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//清空时间，重写设置B的位置，开始位置是A当前的位置</span></span><br><span class="line">                time = <span class="number">0</span>;</span><br><span class="line">                bNowPos = B.transform.position;</span><br><span class="line">                startPos = <span class="keyword">this</span>.transform.position;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//时间每一帧运算累加</span></span><br><span class="line">            time += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//startPos和bNowPos其实定死了，只有time在变化，传入算出下一帧A的位置</span></span><br><span class="line">            pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time * moveSpeed);</span><br><span class="line">            pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time * moveSpeed);</span><br><span class="line">            pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time * moveSpeed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//算出下一帧A的位置赋值给A</span></span><br><span class="line">            <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果:</font></strong></p>
<ul>
<li>第一种：先快后慢的形式</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Mathf%E7%BB%83%E4%B9%A0_%E5%85%88%E5%BF%AB%E5%90%8E%E6%85%A2.gif" class="" title="先快后慢" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>第二种：匀速运动</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Mathf%E7%BB%83%E4%B9%A0_%E5%8C%80%E9%80%9F%E8%BF%90%E5%8A%A8.gif" class="" title="匀速运动" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

</details>


<hr>
<h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p><strong><font size="4">正弦函数（sin）：</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%BC%A6%E5%87%BD%E6%95%B0.png" class="" title="正弦函数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="4">余弦函数（cos）：</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BD%99%E5%BC%A6%E5%87%BD%E6%95%B0.png" class="" title="余弦函数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>




<p><strong><font size="4">三角函数曲线:</font></strong><br><strong><font size="3">正弦函数(sin)曲线:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%BC%A6%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF.png" class="" title="正弦函数曲线" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">余弦函数(cos)曲线:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BD%99%E5%BC%A6%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF.png" class="" title="余弦函数曲线" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="4">常用特殊度数正弦余弦值:</font></strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>0</th>
<th>30</th>
<th>45</th>
<th>60</th>
<th>90</th>
<th>180</th>
<th>270</th>
<th>360</th>
</tr>
</thead>
<tbody><tr>
<td>Sin</td>
<td>0</td>
<td>1/2</td>
<td>√2/2</td>
<td>√3/2</td>
<td>1</td>
<td>0</td>
<td>-1</td>
<td>0</td>
</tr>
<tr>
<td>Cos</td>
<td>1</td>
<td>√3/2</td>
<td>√2/2</td>
<td>1/2</td>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong><font size="4">Unity中的三角函数:</font></strong></p>
<ul>
<li>注意：Mathf中的三角函数相关的函数，传入的参数需要是弧度值</li>
</ul>
<p><strong><font size="3">Sin静态方法:计算正弦函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 返回角度 f 的正弦。</span></span><br><span class="line">    print(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad));<span class="comment">//0.5</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Cos静态方法:计算余弦函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 返回角度 f 的余弦。</span></span><br><span class="line">    print(Mathf.Cos(<span class="number">60</span> * Mathf.Deg2Rad));<span class="comment">//0.5</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">反三角函数:</font></strong></p>
<ul>
<li>反三角函数是初等函数之一</li>
<li>包括反正弦函数、反余弦函数等</li>
<li>作用：通过反三角函数计算正弦值或余弦值对应的弧度值</li>
<li>弧度=Mathf.Asin（正弦值）</li>
<li>弧度=Mathf.Acos（余弦值）</li>
<li>注意：Unity提供的数学计算使用的是弧度制</li>
</ul>
<p><strong><font size="4">Unity中的反三角函数:</font></strong></p>
<ul>
<li>注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度</li>
</ul>
<p><strong><font size="3">Asin静态方法:反正弦函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 返回 f 的反正弦 - 其正弦为 f 的角度（以弧度为单位）。</span></span><br><span class="line">    <span class="built_in">float</span> rad = Mathf.Asin(<span class="number">0.5f</span>);</span><br><span class="line">    print(rad * Mathf.Rad2Deg);<span class="comment">//30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Acoc静态方法:反余弦函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 返回 f 的反余弦 - 其余弦为 f 的角度（以弧度为单位）。</span></span><br><span class="line">    <span class="built_in">float</span> rad = Mathf.Acos(<span class="number">0.5f</span>);</span><br><span class="line">    print(rad * Mathf.Rad2Deg);<span class="comment">//60</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>1.三角函数—— Mathf.Sin（弧度）、Mathf.Cos（弧度）</li>
<li>2.角度和弧度—— Mathf.Rad2Deg、Mathf.Deg2Rad</li>
<li>3.三角函数曲线—— Sin和Cos函数曲线对于我们的意义</li>
<li>4.反三角函数——Mathf.Asin（正弦值）、Mathf.Acos（余弦值）</li>
</ul>
<h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.实现物体按曲线移动（正弦或余弦曲线）</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">创建脚本并创建移动相关参数:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 面朝向移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右曲线移动变化的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> changeSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右曲线移动距离控制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> changeSize = <span class="number">10f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Update函数中写移动逻辑函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// x轴移动</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime); <span class="comment">// moveSpeed控制x轴移动速度快慢</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// y轴移动</span></span><br><span class="line">        time += Time.deltaTime * changeSpeed; <span class="comment">// changeSpeed控制每一帧累加多少时间，时间最终传进去Sin函数中</span></span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.up * changeSize * Time.deltaTime * Mathf.Sin(time)); <span class="comment">// changeSize控制三角函数里的最值 </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0_%E6%9B%B2%E7%BA%BF%E7%A7%BB%E5%8A%A8.gif" class="" title="曲线移动" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
</details>

<h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.世界坐标系</li>
<li>2.(本地)物体坐标系</li>
<li>3.屏幕坐标系</li>
<li>4.视口坐标系</li>
</ul>
<p><strong><font size="4">世界坐标系：</font></strong><br><strong><font size="3">原点：</font></strong></p>
<ul>
<li>世界的中心点</li>
</ul>
<p><strong><font size="3">轴向：</font></strong></p>
<ul>
<li>世界坐标系的三个轴向是固定的</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="" title="世界坐标系" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>this.transform.position —— 返回物体在世界坐标系中的位置</li>
<li>this.transform.rotation —— 返回物体在世界坐标系中的旋转四元数</li>
<li>this.transform.eulerAngles —— 返回物体在世界坐标系中的欧拉角</li>
<li>this.transform.lossyScale —— 返回物体在世界坐标系中的缩放</li>
<li>修改它们将导致相对于世界坐标系的变化</li>
</ul>
<p><strong><font size="4">本地(物体)坐标系：</font></strong><br><strong><font size="3">原点：</font></strong></p>
<ul>
<li>物体的中心点（建模时决定）</li>
</ul>
<p><strong><font size="3">轴向：</font></strong></p>
<ul>
<li>物体右方为x轴正方向</li>
<li>物体上方为y轴正方向</li>
<li>物体前方为z轴正方向</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="" title="本地坐标系" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>this.transform.localPosition —— 返回物体在其父对象坐标系中的位置</li>
<li>this.transform.localEulerAngles —— 返回物体在其父对象坐标系中的旋转四元数</li>
<li>this.transform.localRotation —— 返回物体在其父对象坐标系中的欧拉角</li>
<li>this.transform.localScale —— 返回物体在其父对象坐标系中的缩放</li>
<li>修改它们将导致相对于父对象物体坐标系的变化</li>
</ul>
<p><strong><font size="4">屏幕坐标系：</font></strong><br><strong><font size="3">原点：</font></strong></p>
<ul>
<li>屏幕左下角</li>
</ul>
<p><strong><font size="3">轴向：</font></strong></p>
<ul>
<li>向右为x轴正方向</li>
<li>向上为y轴正方向</li>
</ul>
<p><strong><font size="3">最大宽高：</font></strong></p>
<ul>
<li>Screen.width</li>
<li>Screen.height</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="" title="屏幕坐标系" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>Input.mousePosition —— 返回鼠标在屏幕坐标系中的位置</li>
<li>Screen.width —— 返回屏幕坐标系的宽度</li>
<li>Screen.height —— 返回屏幕坐标系的高度</li>
</ul>
<p><strong><font size="4">视口坐标系：</font></strong><br><strong><font size="3">原点：</font></strong></p>
<ul>
<li>屏幕左下角</li>
</ul>
<p><strong><font size="3">轴向：</font></strong></p>
<ul>
<li>向右为x轴正方向</li>
<li>向上为y轴正方向</li>
</ul>
<p><strong><font size="3">特点：</font></strong></p>
<ul>
<li>左下角为（0，0）</li>
<li>右上角为（1，1）</li>
<li>和屏幕坐标类型，将坐标单位化（归一化）</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E8%A7%86%E5%8F%A3%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="" title="视口坐标系" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">摄像机上的Viewport Rect视口范围：</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Camera_%E8%A7%86%E5%8F%A3%E5%9D%90%E6%A0%87%E7%B3%BB.png" class="" title="Camera上的视口范围" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">坐标相互转换:</font></strong></p>
<p><strong><font size="3">世界转本地:</font></strong></p>
<ul>
<li>this.transform.InverseTransformDirection 将世界空间中的方向向量转换为本地空间中的方向向量。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 worldDirection = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 localDirection = <span class="keyword">this</span>.transform.InverseTransformDirection(worldDirection);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>this.transform.InverseTransformPoint 将世界空间中的点转换为本地空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector3 localPoint = <span class="keyword">this</span>.transform.InverseTransformPoint(worldPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>this.transform.InverseTransformVector 将世界空间中的向量转换为本地空间中的向量。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 worldVector = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 localVector = <span class="keyword">this</span>.transform.InverseTransformVector(worldVector);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">本地转世界:</font></strong></p>
<ul>
<li>this.transform.TransformDirection 将本地空间中的方向向量转换为世界空间中的方向向量。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 localDirection = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 worldDirection = <span class="keyword">this</span>.transform.TransformDirection(localDirection);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>this.transform.TransformPoint 将本地空间中的点转换为世界空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 localPoint = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    Vector3 worldPoint = <span class="keyword">this</span>.transform.TransformPoint(localPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>this.transform.TransformVector 将本地空间中的向量转换为世界空间中的向量。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 localVector = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 worldVector = <span class="keyword">this</span>.transform.TransformVector(localVector);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">世界转屏幕:</font></strong></p>
<ul>
<li>Camera.main.WorldToScreenPoint 将世界空间中的点转换为屏幕空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector3 screenPoint = Camera.main.WorldToScreenPoint(worldPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">屏幕转世界:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 screenPoint = <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 worldPoint = Camera.main.ScreenToWorldPoint(screenPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">世界转视口:</font></strong></p>
<ul>
<li>Camera.main.WorldToViewportPoint 将世界空间中的点转换为视口空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector3 viewportPoint = Camera.main.WorldToViewportPoint(worldPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">视口转世界:</font></strong></p>
<ul>
<li>Camera.main.ViewportToWorldPoint 将视口空间中的点转换为世界空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 viewportPoint = <span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 worldPoint = Camera.main.ViewportToWorldPoint(viewportPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">视口转屏幕:</font></strong></p>
<ul>
<li>Camera.main.ViewportToScreenPoint 将视口空间中的点转换为屏幕空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 viewportPoint = <span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 screenPoint = Camera.main.ViewportToScreenPoint(viewportPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">屏幕转视口</font></strong></p>
<ul>
<li>Camera.main.ScreenToViewportPoint 将屏幕空间中的点转换为视口空间中的点。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 screenPoint = <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">    Vector3 viewportPoint = Camera.main.ScreenToViewportPoint(screenPoint);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Vector3向量模长和单位向量"><a href="#Vector3向量模长和单位向量" class="headerlink" title="Vector3向量模长和单位向量"></a>Vector3向量模长和单位向量</h1><p><code>3D数学-Vector3向量-向量模长和单位向量</code></p>
<h1 id="向量模长和单位向量-详解"><a href="#向量模长和单位向量-详解" class="headerlink" title="向量模长和单位向量 详解"></a>向量模长和单位向量 详解</h1><p><strong><font size="4">学习内容</font></strong></p>
<ul>
<li>1.向量基础</li>
<li>2.向量模长</li>
<li>3.单位向量</li>
</ul>
<p><strong><font size="4">向量基础:</font></strong><br><strong><font size="3">标量：</font></strong></p>
<ul>
<li>有数值大小，没有方向</li>
</ul>
<p><strong><font size="3">向量：</font></strong></p>
<ul>
<li>有数值大小，有方向的矢量</li>
<li>一维：</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%80%E7%BB%B4%E5%90%91%E9%87%8F.png" class="" title="一维向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<ul>
<li>二维：</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BA%8C%E7%BB%B4%E5%90%91%E9%87%8F.png" class="" title="二维向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<ul>
<li>三维：</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8F.png" class="" title="三维向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>向量在空间中的表示:</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%90%91%E9%87%8F%E5%9C%A8%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.png" class="" title="向量在空间中的表示" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<ul>
<li><font color="red">注意：向量在空间中有无数条可以随意移动</font></li>
</ul>
<p><strong><font size="4">Unity中的向量:</font></strong><br><strong><font size="3">三维向量—Vector3:</font></strong></p>
<p><strong><font size="3">Vector3有两种几何意义:</font></strong></p>
<ul>
<li>位置：Vecotr3代表一个点</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">  print(<span class="keyword">this</span>.transform.position);代表对象当前位置</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方向：Vecotr3代表一个方向</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="keyword">this</span>.transform.forward); 代表对象当前位置</span><br><span class="line">    print(<span class="keyword">this</span>.transform.up);代表对象向上的单位向量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Vector2和Vector3基本同理:</font></strong></p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 v = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector2 v2 = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">两点决定一向量:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%A4%E7%82%B9%E5%86%B3%E5%AE%9A%E4%B8%80%E5%90%91%E9%87%8F.png" class="" title="两点决定一向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<blockquote>
<p>A点：（Xa,Ya,Za）;<br>B点：（Xb,Yb,Zb）;<br>从A指向B的向量为AB向量<br>B - A = (Xb - Xa, Yb - Ya, Zb - Za);<br>从B指向A的向量为BA向量<br>A - B = (Xa - Xb, Ya - Yb, Za - Zb);<br><font color="red">口诀：终点减起点</font></p>
</blockquote>
<p><strong><font size="4">Unity中的两点决定一向量:</font></strong></p>
<ul>
<li>Vector3变量A和B此时的几何意义是两个点</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 A = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector3 B = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>用终点减去起点求向量</li>
<li>Vector3变量AB和BA此时的几何意义是两个向量</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 AB = B - A;</span><br><span class="line">    Vector3 BA = A - B;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">零向量和负向量:</font></strong><br><strong><font size="3">零向量（0，0，0）：</font></strong></p>
<ul>
<li>零向量是唯一一个大小为0的向量</li>
</ul>
<p><strong><font size="3">负向量：</font></strong></p>
<ul>
<li>（x,y,z）的负向量为（-x,-y,-z）</li>
<li>负向量和原向量大小相等</li>
<li>负向量和原向量方向相反</li>
</ul>
<p><strong><font size="4">Unity中的零向量和负向量:</font></strong><br><strong><font size="3">零向量:</font></strong></p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(Vector3.zero);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">原向量:</font></strong></p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(Vector3.forward);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">负向量:</font></strong></p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(-Vector3.forward);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">向量的模长:</font></strong></p>
<ul>
<li>向量的模长就是向量的长度</li>
<li>向量是由两个点算出，所以向量的模长就是两个点的距离</li>
</ul>
<p><strong><font size="3">模长公式：</font></strong></p>
<ul>
<li>A向量（x,y,z）</li>
<li>模长=√x²+y²+z²</li>
</ul>
<p><strong><font size="4">Unity中的向量的模长:</font></strong></p>
<p><strong><font size="3">magnitude变量:</font></strong></p>
<ul>
<li>获取向量模长</li>
<li>返回该向量的长度。（只读）</li>
<li>Vector3中提供了获取向量模长的成员属性</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(AB.magnitude); <span class="comment">// AB向量的模长</span></span><br><span class="line">    Vector3 C = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    print(C.magnitude); <span class="comment">// 从原点O出发终点为C的向量OC的模长</span></span><br><span class="line">    <span class="comment">// Distance方法 是通过点的距离获取的长度</span></span><br><span class="line">    <span class="comment">// 返回 a 与 b 之间的距离。</span></span><br><span class="line">    print(Vector3.Distance(A, B)); <span class="comment">// 数值上等于AB.magnitude</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">单位向量:</font></strong></p>
<ul>
<li>模长为1的向量为单位向量</li>
<li>任意一个向量经过归一化就是单位向量</li>
<li>只需要方向，不想让模长影响计算结果时使用单位向量</li>
</ul>
<p><strong><font size="3">归一化公式：</font></strong></p>
<ul>
<li>A向量（x,y,z）</li>
<li>模长=√x²+y²+z²</li>
<li>单位向量=（x/模长，y/模长，z/模长）</li>
</ul>
<p><strong><font size="4">Unity中的单位向量:</font></strong></p>
<p><strong><font size="3">normalized变量:</font></strong></p>
<ul>
<li>获取该向量方向的单位向量 返回同方向长度为1的向量</li>
<li>返回magnitude为1时的该向量。（只读）</li>
<li>Vector3中提供了获取单位向量的成员属性</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(AB.normalized);</span><br><span class="line">    print(AB / AB.magnitude); <span class="comment">// 数值上等于AB.normalized</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="4">学习内容总结:</font></strong></p>
<ul>
<li>向量基础——Vector3是点也是向量，终点减去起点决定一向量</li>
<li>向量模长——magnitude</li>
<li>单位向量——normalized</li>
<li>Vector3这边变量 可以表示一个点 也可以表示一个向量 具体表示什么 是根据我们的具体需求和逻辑决定</li>
<li>如何在Unity里面得到向量 终点减起点 就可以得到向量  点C也可以代表向量 代表的就是 OC向量 O是坐标系原点</li>
<li>得到了向量 就可以利用 Vector3中提供的 成员属性 得到模长和单位向量</li>
<li>模长相当于可以得到 两点之间的距离  单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果</li>
</ul>
<h1 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h1><p><strong><font size="4">1.Unity中判断两点之间距离有几种方式？</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>Distance方法传入AB两个对象的坐标</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform A;</span><br><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(Vector3.Distance(A.position, B.position));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>终点减起点算出BA向量求模长</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform A;</span><br><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print((A.position - B.position).magnitude);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>终点减起点算出AB向量求模长</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform A;</span><br><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print((B.position - A.position).magnitude);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>


<p><strong><font size="4">2.计算向量（3,4,5）的模长（手写）</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>模长计算公式为：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模长 = √(x^<span class="number">2</span> + y^<span class="number">2</span> + z^<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>计算结果:</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模长 = √(<span class="number">3</span>^<span class="number">2</span> + <span class="number">4</span>^<span class="number">2</span> + <span class="number">5</span>^<span class="number">2</span>)</span><br><span class="line">    = √(<span class="number">9</span> + <span class="number">16</span> + <span class="number">25</span>)</span><br><span class="line">    = √(<span class="number">50</span>)</span><br><span class="line">    ≈ <span class="number">7.07</span></span><br></pre></td></tr></tbody></table></figure>

</details>


<p><strong><font size="4">3.计算向量 (3, 4) 的单位向量（手写）</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>单位向量是指模长为1的向量，计算步骤如下：</li>
<li>1.计算向量的模长：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模长 = √(x^<span class="number">2</span> + y^<span class="number">2</span>)</span><br><span class="line">    = √(<span class="number">3</span>^<span class="number">2</span> + (<span class="number">-4</span>)^<span class="number">2</span>)</span><br><span class="line">    = √(<span class="number">9</span> + <span class="number">16</span>)</span><br><span class="line">    = √<span class="number">25</span></span><br><span class="line">    = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>2.计算单位向量：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单位向量 = (<span class="number">3</span>/<span class="number">5</span>, <span class="number">-4</span>/<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>


<h1 id="Vector3向量加减乘除"><a href="#Vector3向量加减乘除" class="headerlink" title="Vector3向量加减乘除"></a>Vector3向量加减乘除</h1><p><code>3D数学-Vector3向量-向量加减乘除</code></p>
<h2 id="向量加减乘除-详解"><a href="#向量加减乘除-详解" class="headerlink" title="向量加减乘除 详解"></a>向量加减乘除 详解</h2><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.向量加法</li>
<li>2.向量减法</li>
<li>3.向量乘除法</li>
</ul>
<p><strong><font size="4">向量加法:</font></strong></p>
<ul>
<li>向量A（Xa,Ya,Za）</li>
<li>向量B（Xb,Yb,Zb）</li>
<li>A+B=（Xa+Xb,Ya+Yb,Za+Zb）</li>
</ul>
<p><strong><font size="3">Vector3+Vector3的意义:</font></strong></p>
<ul>
<li>位置+位置</li>
<li><font color="red">向量+向量</font></li><font color="red">
</font><li><font color="red">位置+向量</font></li>
</ul>
<p><strong><font size="3">位置+位置 几何意义:</font></strong></p>
<ul>
<li>两个位置相加没有任何意义</li>
</ul>
<p><strong><font size="3">向量+向量 几何意义:</font></strong></p>
<ul>
<li>两个向量相加得到一个新向量</li>
<li>向量+向量=向量</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%90%91%E9%87%8F%E5%8A%A0%E5%90%91%E9%87%8F.png" class="" title="向量+向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p>口诀：</p>
<ul>
<li>向量相加，首尾相连</li>
</ul>
<p><strong><font size="3">位置+向量 几何意义:</font></strong></p>
<ul>
<li>位置+向量=位置</li>
<li>向量+位置=位置</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BD%8D%E7%BD%AE%E5%8A%A0%E5%90%91%E9%87%8F.png" class="" title="位置+向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p>口诀：</p>
<ul>
<li>位置和向量相加=平移位置</li>
</ul>
<p><strong><font size="4">Unity中的向量加法:</font></strong></p>
<ul>
<li>可以直接给对象位置加向量 移动物体 但是一般不会这么写 直接translate就行</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>.transform.position += <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(Vector3.forward * <span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">向量减法:</font></strong></p>
<ul>
<li>向量A（Xa,Ya,Za）</li>
<li>向量B（Xb,Yb,Zb）</li>
<li>A-B=（Xa-Xb,Ya-Yb,Za-Zb）</li>
</ul>
<p><strong><font size="3">Vector3-Vector3的意义:</font></strong></p>
<ul>
<li><font color="red">位置-位置</font></li><font color="red">
<li>向量-向量</li>
</font><li><font color="red">位置-向量</font></li>
<li>向量-位置</li>
</ul>
<p><strong><font size="3">位置-位置 几何意义:</font></strong></p>
<ul>
<li>两个位置相减得到一个新向量</li>
<li>位置-位置=向量</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BD%8D%E7%BD%AE%E5%87%8F%E4%BD%8D%E7%BD%AE.png" class="" title="位置-位置" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p>口诀：</p>
<ul>
<li>两点决定一向量</li>
<li>终点-起点</li>
</ul>
<p><strong><font size="3">向量-向量 几何意义:</font></strong></p>
<ul>
<li>两个向量相减得到一个新向量</li>
<li>向量-向量=向量</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%90%91%E9%87%8F%E5%87%8F%E5%90%91%E9%87%8F.png" class="" title="向量减向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p>口诀：</p>
<ul>
<li>向量相减，头连头，尾指尾</li>
<li>A-B=B头指A头</li>
</ul>
<p><strong><font size="3">位置-向量 几何意义:</font></strong></p>
<ul>
<li>位置减向量相当于加负向量</li>
<li>位置+（-向量）=位置</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%BD%8D%E7%BD%AE%E5%87%8F%E5%90%91%E9%87%8F.png" class="" title="位置减向量" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p>口诀：</p>
<ul>
<li>位置减向量=平移位置</li>
</ul>
<p><strong><font size="3">向量-位置 几何意义:</font></strong></p>
<ul>
<li>向量减位置没有任何意义</li>
</ul>
<p><strong><font size="4">Unity中的向量减法:</font></strong></p>
<ul>
<li>可以直接给对象位置减向量 移动物体 但是一般不会这么写 直接translate就行</li>
<li>示例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>.transform.position -= <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(-Vector3.forward * <span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">向量乘除:</font></strong></p>
<ul>
<li>向量只会和标量进行乘除法运算</li>
<li>向量A（x,y,z）</li>
<li>标量a</li>
<li>A<em>a=（x</em>a,y<em>a,z</em>a）</li>
<li>A/a=（x/a,y/a,z/a）</li>
</ul>
<p><strong><font size="3">向量和标量乘除的 几何意义:</font></strong></p>
<ul>
<li>向量*or/标量=向量</li>
<li>向量*or/正数，方向不变，放大缩小摸长</li>
<li>向量*or/负数，方向相反，放大缩小模长</li>
<li>向量*0，得到零向量</li>
</ul>
<p><strong><font size="4">Unity中的向量乘除:</font></strong></p>
<ul>
<li>对于对象的本地缩放可以乘除修改</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>.transform.localScale *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.transform.localScale /= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="keyword">this</span>.transform.lossyScale /= <span class="number">2</span>; <span class="comment">// 全局缩放lossyScale只能读不能改</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.用向量相关知识，实现摄像机跟随(摄像机不设置为对象子物体)，摄像机一直在物体的后方4米，向上偏7米的位置:</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">在 LateUpdate 里设置摄像机位置并看向目标：</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这个脚本将要挂载到摄像机上 实现摄像机跟随</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 练习题一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> zOffect = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> yOffect = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//摄像机的位置 等于目标的位置 进行向量偏移</span></span><br><span class="line">        <span class="comment">//先朝目标对象的 面朝向的反方向平移4米 再朝目标的头顶位置 平移7米</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置摄像机位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = target.position + -target.forward * zOffect + target.up * yOffect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看向目标</span></span><br><span class="line">        <span class="keyword">this</span>.transform.LookAt(target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">运行效果:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%90%91%E9%87%8F%E7%BB%83%E4%B9%A0_%E7%9B%B8%E6%9C%BA%E8%B7%9F%E9%9A%8F.gif" class="" title="向量_相机跟随" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

</details>

<h1 id="Vector3向量点乘"><a href="#Vector3向量点乘" class="headerlink" title="Vector3向量点乘"></a>Vector3向量点乘</h1><p><code>3D数学-Vector3向量-向量点乘</code></p>
<h2 id="向量点乘-详解"><a href="#向量点乘-详解" class="headerlink" title="向量点乘 详解"></a>向量点乘 详解</h2><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.点乘计算公式</li>
<li>2.点乘的几何意义</li>
<li>3.点乘公式推导</li>
</ul>
<p><strong><font size="4">点乘计算公式:</font></strong></p>
<ul>
<li>向量A(Xa,Ya,Za)</li>
<li>向量B(Xb,Yb,Zb)</li>
<li>A·B= Xa<em>Xb + Ya</em>Yb + Za*Zb</li>
<li>向量·向量=标量</li>
</ul>
<p><strong><font size="4">点乘几何意义:</font></strong></p>
<ul>
<li>点乘可以得到一个向量在自己向量上的 <strong><font color="red">投影的长度</font></strong></li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E7%82%B9%E4%B9%98%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" class="" title="点乘几何意义" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<font color="red">

<ul>
<li>点乘结果 &gt; 0 两个向量夹角为锐角</li>
<li>点乘结果 = 0 两个向量夹角为直角</li>
<li>点乘结果 &lt; 0 两个向量夹角为钝角</li>
<li>我们可以用这个规律判断敌人的大致方位</li>
</ul>
</font>

<hr>
<h2 id="补充知识点-调试画线"><a href="#补充知识点-调试画线" class="headerlink" title="补充知识点 调试画线"></a>补充知识点 调试画线</h2><p><strong><font size="3">Debug类中的DrawLine静态方法:画线段</font></strong></p>
<ul>
<li>画线段:在指定的起始点与结束点之间绘制一条直线。</li>
<li>参数:前两个参数分别是起点和终点,最后一个参数是划线颜色。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    Debug.DrawRay(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.up, Color.blue);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Debug类中的DrawRay静态方法:画射线</font></strong></p>
<ul>
<li>画射线:在世界坐标中绘制一条从起点到起点加方向的直线。</li>
<li>参数:前面两个参数分别是起点和方向，最后一个参数是划线颜色。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    Debug.DrawRay(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.up, Color.blue);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意：方向相同的划线可能重合，可能只显示某一划线</p>
</blockquote>
<hr>
<p><strong><font size="3">Dot静态方法:计算两个向量的点积</font></strong></p>
<ul>
<li>Vector3.Dot方法用于计算两个向量的点积。它接受两个Vector3类型的参数，表示要计算点积的两个向量。</li>
<li>示例代码：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 vector1 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Vector3 vector2 = <span class="keyword">new</span> Vector3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> dotProduct = Vector3.Dot(vector1, vector2);</span><br><span class="line">    Debug.Log(<span class="string">"Dot Product: "</span> + dotProduct);<span class="comment">//Dot Product: 32 = 1x4+2x5+3x6</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">通过点乘判断物体的方位:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 思路：用自己的forward向量和自己和目标的位置差算出来的向量点乘判断是否大于0</span></span><br><span class="line">    <span class="comment">// 给用自己的forward向量和目标的位置差算出来的向量划线</span></span><br><span class="line">    Debug.DrawRay(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.forward, Color.red);</span><br><span class="line">    Debug.DrawRay(<span class="keyword">this</span>.transform.position, target.position - <span class="keyword">this</span>.transform.position, Color.red);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dot静态方法 得到两个向量的点乘结果</span></span><br><span class="line">    <span class="comment">// 两个向量的点积。</span></span><br><span class="line">    <span class="comment">// Vector3 提供了计算点乘的方法</span></span><br><span class="line">    <span class="comment">// 向量 a 点乘 AB 的结果</span></span><br><span class="line">    <span class="built_in">float</span> dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward, target.position - <span class="keyword">this</span>.transform.position);</span><br><span class="line">    <span class="keyword">if</span> (dotResult &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"它在我前方"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"它在我后方"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E7%82%B9%E4%B9%98%E5%88%A4%E6%96%AD%E7%89%A9%E4%BD%93%E6%96%B9%E4%BD%8D.gif" class="" title="点乘判断物体的方位" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">点乘角度公式推导:</font></strong></p>
<div align="center">
<style>.auiwjahrvfso{}</style><img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E7%82%B9%E4%B9%98%E8%A7%92%E5%BA%A6%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" class="auiwjahrvfso" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
</div>


<ul>
<li>1.Cosβ = 直角边 / 单位向量B模长<br>  直角边 = Cosβ * 单位向量B模长<br>  +(↓)  </li>
<li>2.直角边 = 单位向量A · 单位向量B<br>↓</li>
<li>Cosβ * 单位向量B模长 = 单位向量A · 单位向量B<br>↓</li>
<li>Cosβ = 单位向量A · 单位向量B<br>↓</li>
<li>推出结果：β = Acos(单位向量A · 单位向量B)</li>
</ul>
<p><strong><font size="4">通过点乘推导公式算出夹角:</font></strong></p>
<ul>
<li>手动通过点乘公式计算两个向量之间的夹角的步骤如下：</li>
</ul>
<p><strong><font size="3">1.使用单位向量计算点乘结果：</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward, (target.position - <span class="keyword">this</span>.transform.position).normalized);</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">2.使用反余弦三角函数得出角度，并将弧度制转换为角度制：</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"手动算出的角度-"</span> + Mathf.Acos(dotResult) * Mathf.Rad2Deg);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这些步骤可以用来手动计算两个向量之间的夹角，适用于需要更细致控制或理解计算过程的情况。</p>
</blockquote>
<p><strong><font size="4">Angle静态方法:计算两个向量之间的夹角</font></strong></p>
<ul>
<li>Vector3.Angle静态方法用于计算两个向量之间的夹角，并以度为单位返回该角度。</li>
<li>参数：from表示起始向量，to表示目标向量。</li>
<li>返回值：from向量与to向量之间的夹角（以度为单位）。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 fromVector = <span class="keyword">this</span>.transform.forward;</span><br><span class="line">    Vector3 toVector = target.position - <span class="keyword">this</span>.transform.position;</span><br><span class="line">    <span class="built_in">float</span> angle = Vector3.Angle(fromVector, toVector);</span><br><span class="line">    print(<span class="string">"Angle静态方法算出的角度-"</span> + angle);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意：返回的角度范围是0到180度之间，表示两个向量之间的夹角。</p>
</blockquote>
<h2 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.当一个物体B在物体A前方45度角范围内，并且离A只有5米距离时，在控制台打印“发现入侵者”</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">手动算出角度:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAngle</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Transform B;<span class="comment">//得到B的位置信息 拖拽赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (Vector3.Distance(<span class="keyword">this</span>.transform.position, B.transform.position) &lt;= <span class="number">5</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 第一步：算出点乘结果（方向向量）</span></span><br><span class="line">            <span class="built_in">float</span> dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward, (B.transform.position - <span class="keyword">this</span>.transform.position).normalized);</span><br><span class="line">            <span class="comment">// 第二步：通过反余弦函数算出夹角</span></span><br><span class="line">            <span class="keyword">if</span> (Mathf.Acos(dotResult) * Mathf.Rad2Deg &lt;= <span class="number">22.5f</span>)</span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"手动算角度 发现入侵者"</span>);</span><br><span class="line">            }   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Angle直接算角度:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAngle</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Transform B;得<span class="comment">//到B的位置信息 拖拽赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Angle直接算角度</span></span><br><span class="line">        <span class="keyword">if</span> (Vector3.Distance(<span class="keyword">this</span>.transform.position, B.transform.position) &lt;= <span class="number">5</span> &amp;&amp; Vector3.Angle(<span class="keyword">this</span>.transform.forward, B.transform.position - <span class="keyword">this</span>.transform.position) &lt;= <span class="number">22.5f</span>)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"Angle直接算角度 发现入侵者"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">绘制实心扇形，方便测试观看</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> radius = <span class="number">5f</span>;  <span class="comment">// 扇形半径</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> angle = <span class="number">45f</span>;  <span class="comment">// 扇形角度</span></span><br><span class="line"><span class="keyword">public</span> Color arcColor = Color.yellow;  <span class="comment">// 扇形颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">{</span><br><span class="line">     <span class="comment">// 设置颜色</span></span><br><span class="line">    Handles.color = arcColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算扇形起点和终点的方向</span></span><br><span class="line">    Vector3 forward = m_target.forward;  <span class="comment">// 扇形的正前方向</span></span><br><span class="line">    Vector3 fromDirection = Quaternion.Euler(<span class="number">0</span>,-angle/<span class="number">2</span>, <span class="number">0</span>) * forward;  <span class="comment">// 扇形左边界</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制实心扇形</span></span><br><span class="line">    Handles.DrawSolidArc(m_target.position, Vector3.up, fromDirection, angle, -radius);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E7%82%B9%E4%B9%98%E7%BB%83%E4%B9%A0_%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B.gif" class="" title="点乘练习_检测范围" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<blockquote>
<p>这两种方法都实现了在物体B位于物体A前方45度角范围内，并且距离A不超过5米时，在控制台打印“发现入侵者”的功能。判断边界是22.5原因是45分开了两边。</p>
</blockquote>
</details>

<h1 id="Vector3向量叉乘"><a href="#Vector3向量叉乘" class="headerlink" title="Vector3向量叉乘"></a>Vector3向量叉乘</h1><p><code>3D数学-Vector3向量-向量叉乘</code></p>
<h2 id="向量叉乘-详解"><a href="#向量叉乘-详解" class="headerlink" title="向量叉乘 详解"></a>向量叉乘 详解</h2><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.叉乘计算公式</li>
<li>2.叉乘几何意义</li>
</ul>
<p><strong><font size="4">叉乘计算公式：</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%8F%89%E4%B9%98%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" class="" title="叉乘的计算公式" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li><font color="red">向量 × 向量 = 向量</font></li>
<li>向量A(Xa,Ya,Za)</li>
<li>向量B(Xb,Yb,Zb)</li>
<li>A × B = (X,Y,Z)</li>
<li>X = YaZb - ZaYb</li>
<li>Y = ZaXb - XaZb</li>
<li>Z = XaYb - YaXb</li>
</ul>
<p><strong><font size="3">Cross静态方法:计算两个向量的叉乘</font></strong></p>
<ul>
<li>Vector3.Cross静态方法用于计算两个向量的叉乘，并返回叉积的结果向量。</li>
<li>参数：两个向量a和b。</li>
<li>返回值：叉积的结果向量，垂直于a和b所在的平面。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transform A,B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Vector3 result = Vector3.Cross(A.position, B.position);</span><br><span class="line">    print(result);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">叉乘的几何意义:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%8F%89%E4%B9%98%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" class="" title="叉乘的几何意义" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>A × B 得到的向量同时垂直A和B</li>
<li>A × B 向量垂直于A和B组成的平面</li>
<li>A × B = -(B × A)</li>
</ul>
<blockquote>
<p>数学中的叉乘方向使用右手法则。<br>Unity当中使用左手法则，因为Unity使用的是左手坐标系</p>
</blockquote>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transform A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 假设向量 A和B 都在 XZ平面上</span></span><br><span class="line">    <span class="comment">// 向量A 叉乘 向量 B 会得到垂直于向量A和向量B所在的平面的向量，又称法向量</span></span><br><span class="line">    <span class="comment">// y大于0 证明 B在A右侧</span></span><br><span class="line">    <span class="comment">// y小于0 证明 B在A左侧</span></span><br><span class="line"></span><br><span class="line">    Vector3 C1 = Vector3.Cross(A.position, B.position);</span><br><span class="line">    <span class="keyword">if</span> (C1.y &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"B在A的右侧"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"B在A的左侧"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Vector3 C2 = Vector3.Cross(B.position, A.position);</span><br><span class="line">    <span class="keyword">if</span> (C2.y &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"A在B的右侧"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"A在B的左侧"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>向量叉乘对于我们的意义</li>
<li>1.得到一个平面的法向量</li>
<li>2.得到两个向量之间的左右位置关系</li>
</ul>
<h2 id="练习题-5"><a href="#练习题-5" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.判断一个物体B位置再另一个物体A的位置的左上，左下，右上，右下哪个方位</font></strong><br><strong><font size="3">计算 A 位置向量和 AB 方向差向量的点乘和叉乘结果</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestScript</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//拖拽得到AB位置变量</span></span><br><span class="line">    <span class="keyword">public</span> Transform A;</span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点乘接过和叉乘结果变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> dotResult;</span><br><span class="line">    <span class="keyword">private</span> Vector3 crossResult;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        dotResult = Vector3.Dot(A.forward, B.position - A.position);</span><br><span class="line">        crossResult = Vector3.Cross(A.forward, B.position - A.position);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">根据点乘和叉乘的值判断方位</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestScript</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> Update</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (dotResult &gt;= <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 右侧</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"右前"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左侧</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"左前"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 右侧</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"右后"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左侧</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"左后"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%8F%89%E4%B9%98%E7%BB%83%E4%B9%A01_%E5%88%A4%E6%96%AD%E6%96%B9%E4%BD%8D.gif" class="" title="叉乘练习1_检测方位" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">2.当一个物体B在物体A左前角20度角或右前方30度范围内，并且离A只有5米距离时，在控制台打印 “发现入侵者”</font></strong></p>
<p><strong><font size="3">计算叉乘用于判断左边还是右边</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestScript</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> Vector3 crossResult;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        crossResult = Vector3.Cross(A.forward, B.position - A.position);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">判断距离后再判断左右和角度</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestScript</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 判断距离</span></span><br><span class="line">        <span class="keyword">if</span> (Vector3.Distance(A.position, B.position) &lt;= <span class="number">5</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 判断角度和左右逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span> &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= <span class="number">30</span> || crossResult.y &lt; <span class="number">0</span> &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= <span class="number">20</span>)      </span><br><span class="line">            {</span><br><span class="line">                print(<span class="string">"发现入侵者"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">绘制实心扇形，方便测试观看</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> radius = <span class="number">5f</span>;  <span class="comment">// 扇形半径</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> angle = <span class="number">45f</span>;  <span class="comment">// 扇形角度</span></span><br><span class="line"><span class="keyword">public</span> Color arcColor = Color.yellow;  <span class="comment">// 扇形颜色</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">float</span> m_eulerY = <span class="number">-15</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">{</span><br><span class="line">   <span class="comment">// 设置颜色</span></span><br><span class="line">    Handles.color = arcColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算扇形起点和终点的方向</span></span><br><span class="line">    Vector3 forward = A.forward;  <span class="comment">// 扇形的正前方向</span></span><br><span class="line">    Vector3 fromDirection = Quaternion.Euler(<span class="number">0</span>, m_eulerY, <span class="number">0</span>) * forward;  <span class="comment">// 扇形左边界</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制实心扇形</span></span><br><span class="line">    Handles.DrawSolidArc(A.position, Vector3.up, fromDirection, angle, radius);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E5%8F%89%E4%B9%98%E7%BB%83%E4%B9%A02_%E6%A3%80%E6%B5%8B%E8%8C%83%E5%9B%B4.gif" class="" title="叉乘练习2_检测范围" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<h1 id="Vector3向量差值运算"><a href="#Vector3向量差值运算" class="headerlink" title="Vector3向量差值运算"></a>Vector3向量差值运算</h1><p><code>3D数学-Vector3向量-向量插值运算</code></p>
<h2 id="向量差值运算-详解"><a href="#向量差值运算-详解" class="headerlink" title="向量差值运算 详解"></a>向量差值运算 详解</h2><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>线性插值</li>
<li>球形差值</li>
</ul>
<p><strong><font size="4">线性插值:</font></strong></p>
<p><strong><font size="3">函数:</font></strong></p>
<ul>
<li>Vector3.Lerp(start,end,t);</li>
<li>对两个点进行插值运算</li>
<li>t的取值范围为: 0 ~ 1</li>
</ul>
<p><strong><font size="3">公式:</font></strong></p>
<ul>
<li>result = start + (end-start) * t</li>
</ul>
<p><strong><font size="4">线性插值的应用:</font></strong></p>
<ul>
<li>Vector3.Lerp(start,end,t);</li>
<li>每帧改变start的值（先快后慢）</li>
<li>每帧改变t的值（匀速运动）</li>
</ul>
<p><strong><font size="3">Lerp静态方法:在两点进行线性插值</font></strong></p>
<ul>
<li>Vector3.Lerp静态方法用于在两个点之间进行线性插值。</li>
<li>参数：起始点start、结束点end和插值系数t。</li>
<li>返回值：在起始点和结束点之间根据插值系数进行插值后的点。</li>
</ul>
<p><strong><font size="3">先快后慢:每帧改变start位置 位置无限接近 但不会得到end位置</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"><span class="keyword">public</span> Transform A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 可以理解为t不变 每次往方向向量加的值(end - start)一直会变小</span></span><br><span class="line">    A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong><font size="3">匀速运动:每帧改变时间 当t&gt;=1时 得到结果</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3 nowTarget;</span><br><span class="line">print <span class="built_in">float</span> time</span><br><span class="line"><span class="keyword">private</span> Vector3 startPos;</span><br><span class="line"><span class="keyword">public</span> Transform B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    startPos = B.position;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 可以理解为t每一帧累加相同值 start和(end - start)不变 所以是匀速运动</span></span><br><span class="line">    <span class="comment">// 这种匀速移动 当time&gt;=1时  我改变了 目标位置后  它会直接瞬移到我们的目标位置 因为t&gt;=1时直接的得到结果</span></span><br><span class="line">    <span class="comment">// 所以要做特殊处理 每次改变目标位置时 清空时间</span></span><br><span class="line">    <span class="keyword">if</span> (nowTarget != target.position)</span><br><span class="line">    {</span><br><span class="line">        nowTarget = target.position;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        startPos = B.position;</span><br><span class="line">    }</span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    B.position = Vector3.Lerp(startPos, nowTarget, time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><strong><font size="4">球形差值:</font></strong><br><strong><font size="3">函数:</font></strong></p>
<ul>
<li>Vector3.Slerp(start,end,t);</li>
<li>对两个点进行插值运算</li>
<li>t的取值范围为: 0 ~ 1</li>
</ul>
<p><strong><font size="4">线性差值和球形差值的区别:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E7%BA%BF%E6%80%A7%E5%92%8C%E7%90%83%E5%BD%A2%E5%B7%AE%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB.png" class="" title="线性差值和球形差值的区别" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">Slerp静态方法:在两点进行球形插值</font></strong></p>
<ul>
<li>Vector3.Slerp静态方法用于在两个向量之间进行球形插值。</li>
<li>参数：起始向量from、目标向量to和插值系数t。</li>
<li>返回值：在起始向量和目标向量之间根据插值系数进行球形插值后的向量。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Transform C;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    time2 += Time.deltaTime;</span><br><span class="line">    C.position = Vector3.Slerp(Vector3.right * <span class="number">10</span>, Vector3.forward * <span class="number">10</span>, time2 * <span class="number">0.1f</span>);</span><br><span class="line">    <span class="comment">// 位置会从(10,0,0)按球形轨迹慢慢的变到(0,10,0)</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="3">线性差值:</font></strong></p>
<ul>
<li>用于跟随移动，摄像机跟随</li>
</ul>
<p><strong><font size="3">球形差值:</font></strong></p>
<ul>
<li>用于曲线运行，模拟太阳运动弧线</li>
</ul>
<h2 id="练习题-6"><a href="#练习题-6" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">用线性插值相关知识，实现摄像机跟随(摄像机不设置为对象子物体)，摄像机一直在物体的后方4米，向上偏7米的位置</font></strong></p>
<ul>
<li>这是向量加减乘除练习题的做法，现在是想慢慢按照插值规则动</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 摄像机的位置 等于目标的位置 进行向量偏移</span></span><br><span class="line">    <span class="comment">// 先朝目标对象的面朝向的反方向平移4米 再朝目标的头顶位置 平移7米</span></span><br><span class="line">    <span class="comment">// 设置摄像机位置</span></span><br><span class="line">    <span class="keyword">this</span>.transform.position = target.position + -target.forward * zOffect + target.up * yOffect;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">先快后慢的移动</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> zOffect = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> yOffect = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Vector3 cameraTargetPos;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置</span></span><br><span class="line">    <span class="keyword">if</span> (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)</span><br><span class="line">    {</span><br><span class="line">        cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 摄像机的位置 等于目标的位置 进行向量偏移</span></span><br><span class="line">    <span class="comment">// 先朝目标对象的面朝向的反方向平移4米 再朝目标的头顶位置 平移7米</span></span><br><span class="line">    <span class="keyword">this</span>.transform.position = Vector3.Lerp(<span class="keyword">this</span>.transform.position, cameraTargetPos, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.transform.LookAt(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/V3%E5%B7%AE%E5%80%BC%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A01_%E5%85%88%E5%BF%AB%E5%90%8E%E6%85%A2.gif" class="" title="先快后慢" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">匀速移动</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> zOffect = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> yOffect = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Vector3 cameraTargetPos;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"><span class="keyword">private</span> Vector3 startPos;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置 记录摄像机当前开始位置 重置时间</span></span><br><span class="line">    <span class="keyword">if</span> (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)</span><br><span class="line">    {</span><br><span class="line">        cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect;</span><br><span class="line">        startPos = <span class="keyword">this</span>.transform.position;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    <span class="keyword">this</span>.transform.position = Vector3.Lerp(startPos, cameraTargetPos, time * moveSpeed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.transform.LookAt(target);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/V3%E5%B7%AE%E5%80%BC%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A01_%E5%8C%80%E9%80%9F%E8%BF%90%E5%8A%A8.gif" class="" title="先快后慢" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="4">通过球形插值模拟太阳的升降变化</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Transform sun;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time2;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    time2 += Time.deltaTime;</span><br><span class="line">    <span class="comment">//sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10, time2 * 0.1f);//假如直接写最终值会不知道从哪里转 可能会平这转</span></span><br><span class="line">    sun.position = Vector3.Slerp(Vector3.right * <span class="number">10</span>, Vector3.left * <span class="number">10</span> + Vector3.up * <span class="number">0.1f</span>, time2 * <span class="number">0.1f</span>);<span class="comment">//要给最终值加一点向上的向量 才会往上转</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/V3%E5%90%91%E9%87%8F%E5%B7%AE%E5%80%BC%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A02_%E6%A8%A1%E6%8B%9F%E5%A4%AA%E9%98%B3%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D.gif" class="" title="模拟太阳的上升下降" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>














<h1 id="Quaternion四元数的使用原因"><a href="#Quaternion四元数的使用原因" class="headerlink" title="Quaternion四元数的使用原因"></a>Quaternion四元数的使用原因</h1><p><code>3D数学-Quaternion四元数-为何使用四元数</code></p>
<h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.欧拉角</li>
<li>2.万向节死锁</li>
</ul>
<p><strong><font size="4">欧拉角:</font></strong></p>
<ul>
<li>由三个角度(x,y,z)组成</li>
<li>在特点坐标系下用于描述物体的旋转量</li>
<li>空间中的任意旋转都可以分界成绕</li>
<li>三个互相垂直轴的三个旋转角组成的序列</li>
</ul>
<p><strong><font size="3">欧拉角旋转约定:</font></strong></p>
<ul>
<li>heading —— pitch —— bank</li>
<li>是一种最常见的旋转序列约定</li>
<li>Y - X - Z 约定</li>
<li>heading:物质绕自身的对象坐标系的 <font color="red">Y轴</font> ，旋转的角度</li>
<li>pitch:物质绕自身的对象坐标系的 <font color="red">X轴</font> ，旋转的角度</li>
<li>bank:物质绕自身的对象坐标系的 <font color="red">Z轴</font> ，旋转的角度</li>
</ul>
<p><strong><font size="4">Unity中的欧拉角:</font></strong></p>
<ul>
<li>Inspector 窗口中调节的 Rotation 就是欧拉角</li>
<li><font color="red">this.transform.eulerAngles</font>得到的就是欧拉角角度</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Inspector%E7%AA%97%E5%8F%A3_%E6%AC%A7%E6%8B%89%E8%A7%92%E8%A7%92%E5%BA%A6.jpg" class="" title="欧拉角角度" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">代码获取:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="keyword">this</span>.transform.eulerAngles);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">欧拉角的优缺点:</font></strong><br><strong><font size="3">优点:</font></strong></p>
<ul>
<li>直观、易理解</li>
<li>存储空间小（三个数表示）</li>
<li>可以进行从一个方向到另一个方向旋转大于180°的角度</li>
</ul>
<p><strong><font size="3">缺点:</font></strong></p>
<ul>
<li>同一旋转的表示不唯一</li>
<li>万向节死锁</li>
</ul>
<p><strong><font size="4">万向节死锁:</font></strong></p>
<ul>
<li>当某个特点轴 达到某个特殊值时</li>
<li>绕一个轴旋转可能会覆盖住另一个轴的旋转</li>
<li>从而失去一维自由度</li>
</ul>
<p><strong><font size="3">在Unity中观察万向节死锁:</font></strong></p>
<ul>
<li>在Unity中创建一个cube，在旋转其x轴到90度后，选择y轴或z轴进行旋转，会发现效果相同。这种现象称为万向节死锁。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E4%B8%87%E5%90%91%E8%8A%82%E6%AD%BB%E9%94%81.gif" class="" title="万向节死锁" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<h1 id="Quaternion四元数是什么"><a href="#Quaternion四元数是什么" class="headerlink" title="Quaternion四元数是什么"></a>Quaternion四元数是什么</h1><p><code>3D数学-Quaternion四元数-四元数是什么</code></p>
<p><strong><font size="4">知识回顾:</font></strong></p>
<ul>
<li>欧拉角由缺点所以我们使用四元数</li>
<li>缺点1：同一旋转的表示不唯一</li>
<li>缺点2：万向节死锁</li>
</ul>
<p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.四元素构成</li>
<li>2.Unity中的四元素</li>
<li>3.四元素弥补的欧拉角的缺点</li>
</ul>
<p><strong><font size="4">四元素构成:</font></strong></p>
<p><strong><font size="3">四元数概念:</font></strong></p>
<ul>
<li>四元数是简单的超复数</li>
<li>由实数加上三个虚数单位组成</li>
<li>主要用于在三维空间中表示旋转</li>
</ul>
<blockquote>
<p>四元数原理包含大量数学相关知识，较为复杂<br>比如：复数、思维空间等等<br>因此只对其基本构成和基本公式进行讲解<br>如果想深入了解数学原理请从数学层面去找资料了解</p>
</blockquote>
<p><strong><font size="3">四元数构成:</font></strong></p>
<ul>
<li>一个四元数包含一个标量和一个3D向量</li>
<li>[w,v],w为标量，v为3D向量</li>
<li>[w,(x,y,z)]</li>
<li>对于给定的任意一个四元数：</li>
<li>表示3D空间中的一个旋转量</li>
</ul>
<p><strong><font size="3">轴-角对:</font></strong></p>
<ul>
<li>在3D空间中，任意旋转都可以表示绕着某一个轴旋转一个旋转角得到</li>
</ul>
<blockquote>
<p>注意：该轴并不是空间中的x，y，z轴，而是任意一个轴</p>
</blockquote>
<h2 id="TOOD补齐"><a href="#TOOD补齐" class="headerlink" title="TOOD补齐"></a>TOOD补齐</h2><h1 id="Quaternion四元素常用方法"><a href="#Quaternion四元素常用方法" class="headerlink" title="Quaternion四元素常用方法"></a>Quaternion四元素常用方法</h1><p><code>3D数学-Quaternion四元数-四元数常用方法</code></p>
<p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.单位四元素</li>
<li>2.插值运算</li>
<li>3.向量方向 转换为 对应四元素角度</li>
</ul>
<p><strong><font size="4">单位四元素:</font></strong></p>
<ul>
<li>单位四元数表示没有旋转量（角位移）</li>
<li>当角度为0或者360°时</li>
<li>对于给定轴都会得到单位四元数</li>
<li>[1,(0,0,0)]和[-1,(0,0,0)]都是单位四元素 表示没有旋转量</li>
<li>四元数Q= [cos(β/2),sin(β/2)x,sin(β/2)y,sin(β/2)z]</li>
<li>当β为0或者360°时，代入计算就是[1,(0,0,0)]或[-1,(0,0,0)]</li>
</ul>
<p><strong><font size="3">identity静态变量:代表单位四元数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试立方体</span></span><br><span class="line"><span class="keyword">public</span> Transform testCube;<span class="comment">//Rotation(50,50,50)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//单位旋转（只读）。</span></span><br><span class="line">    print(Quaternion.identity);</span><br><span class="line">    testCube.rotation = Quaternion.identity;</span><br><span class="line">    <span class="comment">//测试立方体无论当前旋转如何 都会恢复成每个轴都不旋转的(0,0,0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object的Instantiate方法有重载 第三个参数可以传入四元数角度</span></span><br><span class="line">    Instantiate(testCube, Vector3.zero, Quaternion.identity);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">四元数差值运算:</font></strong></p>
<ul>
<li>四元素中同样提供如图Vector3的差值运算</li>
<li>Lerp和Slerp</li>
<li>在四元数中Lerp和Slerp只有一些细微差别</li>
<li>由于算法不同</li>
<li>Slerp的效果会好一些</li>
<li></li>
</ul>
<blockquote>
<p>Lerp的效果相比Slerp更快但是如果旋转范围较大较高较差<br>所以建议使用Slerp进行插值运算</p>
</blockquote>
<p><strong><font size="3">Lerp静态方法:四元数线性插值进行旋转</font></strong></p>
<ul>
<li>Lerp静态方法用于在两个四元数之间进行线性插值。</li>
<li>Lerp静态方法是Quaternion结构体提供的一个功能，用于在两个四元数之间进行线性插值。线性插值通常用于在两个值之间以线性方式进行平滑过渡。对于四元数，Lerp方法将在两个四元数之间进行插值，并返回一个介于它们之间的新四元数。此外，该方法还会对结果进行标准化处理，确保返回的四元数仍然代表一个单位旋转。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">Lerp</span>(<span class="params">Quaternion a, Quaternion b, <span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>a：起始四元数。</li>
<li>b：目标四元数。</li>
<li>t：插值系数，表示在起始和目标之间的插值程度。它的取值范围通常在 [0, 1] 之间。当t为0时，返回a；当t为1时，返回b。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Quaternion a = Quaternion.Euler(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>); <span class="comment">// 起始四元数</span></span><br><span class="line">    Quaternion b = Quaternion.Euler(<span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>); <span class="comment">// 目标四元数</span></span><br><span class="line">    <span class="built_in">float</span> t = <span class="number">0.5f</span>; <span class="comment">// 插值系数</span></span><br><span class="line"></span><br><span class="line">    Quaternion result = Quaternion.Lerp(a, b, t);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在这个示例中，我们从一个代表绕Y轴旋转45度的四元数 a，过渡到另一个代表绕Y轴旋转90度的四元数 b。通过将插值系数 t 设置为0.5，我们在这两个旋转之间进行了平滑的线性插值，并得到了一个新的四元数 result。</p>
</blockquote>
<p><strong><font size="3">Slerp静态方法:四元数球形插值进行旋转</font></strong></p>
<ul>
<li>Slerp静态方法用于在两个四元数之间进行球形插值。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//三个立方体 想让立方体A和立方体B慢慢变成和立方体target相同旋转</span></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> Transform A;</span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quaternion start;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Update内</span></span><br><span class="line">    <span class="comment">// 在四元数 a 与 b 之间按比率 t 进行球形插值。参数 t 限制在范围[0, 1] 内。</span></span><br><span class="line">    <span class="comment">// 想让立方体A和立方体B慢慢变成和立方体target相同旋转</span></span><br><span class="line">    <span class="comment">// 无限接近，先快后慢</span></span><br><span class="line">    <span class="comment">// 传入当前旋转四元数和目标旋转四元数，每帧变化赋值给下一帧旋转四元数</span></span><br><span class="line">    A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);</span><br><span class="line">    <span class="comment">// 匀速变化，time&gt;=1到达目标</span></span><br><span class="line">    <span class="comment">// 定死开始旋转四元数和目标旋转四元数，累加事件</span></span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    <span class="comment">// 开始旋转四元数在Start()内 start = B.transform.rotation 赋好值</span></span><br><span class="line">    B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);</span><br><span class="line"></span><br><span class="line">}    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">向量指向转四元数:</font></strong></p>
<ul>
<li>Quaternion.LookRotation(面朝向量);</li>
<li>LookRotation方法可以将传入的面朝向量转换为对应的四元素角度信息</li>
<li>举例：当人物面朝向需要改变时，只需要把目标面朝向传入该函数，便可以得到目标四元数角度信息，之后将任务四元数角度信息改为得到的信息即可达到转向</li>
</ul>
<p><strong><font size="3">LookRotation静态方法:获得向量指向转四元数</font></strong></p>
<ul>
<li>LookRotation静态方法用于使用指定的forward和upwards方向创建旋转。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform lookA;</span><br><span class="line"><span class="keyword">public</span> Transform lookB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 目标是想让A立即转向看向B</span></span><br><span class="line">    <span class="comment">// 先让lookA和lookB位置相减算出lookAB向量，传入LookRotation静态方法中，获得返回的四元数赋值给lookA</span></span><br><span class="line">    Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);</span><br><span class="line">    lookA.rotation = q;</span><br><span class="line">    <span class="comment">// 资源实现的效果和Transform中的静态方法LookAt方法类似</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="3">单位四元素:</font></strong></p>
<ul>
<li>用于对象角度初始化<br><strong><font size="3">插值运算:</font></strong></li>
<li>用于平滑旋转<br><strong><font size="3">向量指向转四元数:</font></strong></li>
<li>用于让对象朝向某方向</li>
</ul>
<h2 id="练习题-7"><a href="#练习题-7" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.利用四元数的LookRotation方法，实现LookAt的效果</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>假设Transform类没有LookAt方法，创建Tools脚本，为Transform类提供效果和LookAt方法效果一样的拓展方法</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//自己写的看向目标的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyLookAt</span>(<span class="params"><span class="keyword">this</span> Transform obj, Transform target</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//算出目标和自己的向量</span></span><br><span class="line">        Vector3 vec = target.position - obj.position;</span><br><span class="line">        <span class="comment">//用LookRotation得到转向的四元数赋值给自己</span></span><br><span class="line">        obj.transform.rotation = Quaternion.LookRotation(vec);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用自己写的拓展方法看向B</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Transform lookA;</span><br><span class="line">    <span class="keyword">public</span> Transform lookB;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//调用自己写的拓展方法看向B</span></span><br><span class="line">        lookA.MyLookAt(lookB);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<p><strong><font size="4">2.将之前摄像机移动的练习题中的LookAt换成LookRotation实现，并且通过Slerp来缓慢看向玩家</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">摄像机先快后慢旋转看向目标</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="comment">//目标旋转角度四元数</span></span><br><span class="line">    <span class="keyword">private</span> Quaternion targetQ;</span><br><span class="line">    <span class="comment">//旋转速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 用目标的位置 减去 摄像机的位置 得到新的面朝向向量四元数</span></span><br><span class="line">    targetQ = Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position);</span><br><span class="line">    <span class="comment">// 调用球形插值 传入当前摄像机当前旋转四元数、面朝向向量四元数、以及旋转速度 赋值给下一帧摄像机当前旋转</span></span><br><span class="line">    <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, targetQ, Time.deltaTime * roundSpeed);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">摄像机匀速旋转看向目标</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="comment">//目标旋转角度四元数</span></span><br><span class="line">    <span class="keyword">private</span> Quaternion targetQ;</span><br><span class="line">    <span class="comment">//旋转速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed;</span><br><span class="line">    <span class="comment">//旋转累加事件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> roundTime;</span><br><span class="line">    <span class="comment">//开始时的旋转四元数</span></span><br><span class="line">    <span class="keyword">private</span> Quaternion startQ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 当发现目标对象位置改变时</span></span><br><span class="line">    <span class="keyword">if</span> (targetQ != Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数</span></span><br><span class="line">        targetQ = Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position);</span><br><span class="line">        <span class="comment">// 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果</span></span><br><span class="line">        roundTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重置摄像机开始旋转位置</span></span><br><span class="line">        startQ = <span class="keyword">this</span>.transform.rotation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加时间</span></span><br><span class="line">    roundTime += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间</span></span><br><span class="line">    <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>























<h1 id="Quaternion四元数计算"><a href="#Quaternion四元数计算" class="headerlink" title="Quaternion四元数计算"></a>Quaternion四元数计算</h1><p><code>3D数学-Quaternion四元数-四元数计算</code></p>
<p><strong><font size="4">学习内容:</font></strong></p>
<ul>
<li>1.四元数相乘</li>
<li>2.四元数乘向量</li>
</ul>
<p><strong><font size="4">四元数相乘:</font></strong></p>
<ul>
<li>q3 = q1 * q2 </li>
<li>两个四元数相乘得到一个新的四元数</li>
<li>代码两个旋转量的叠加</li>
<li>相当于旋转</li>
</ul>
<blockquote>
<p>注意：旋转相对的坐标系是物体自身坐标系</p>
</blockquote>
<p><strong><font size="3">AngleAxis静态方法:通过轴角对API进行旋转</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本挂载到立方体上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//通过轴角对API传入要转的轴和角度</span></span><br><span class="line">    <span class="comment">//绕着y轴转20度</span></span><br><span class="line">    Quaternion q = Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up);</span><br><span class="line">    <span class="comment">//乘上这个脚本挂载的立方体当前旋转四元数 让这个脚本挂载的立方体绕着y轴转20度</span></span><br><span class="line">    <span class="comment">//this.transform.rotation = this.transform.rotation * q;</span></span><br><span class="line">    <span class="keyword">this</span>.transform.rotation *= q;</span><br><span class="line">    <span class="comment">//注意1：用四元数旋转完可能和Inspector窗口上的旋转对不上 不用管它</span></span><br><span class="line">    <span class="comment">//注意2：旋转相对的坐标系 是物体自身坐标系 </span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">四元数乘向量:</font></strong></p>
<ul>
<li>v2 = q1 * v1 </li>
<li>四元数乘向量返回一个新向量</li>
<li>可以将指定向量旋转对应四元数的旋转量</li>
<li>相当于旋转向量</li>
</ul>
<p><strong><font size="3">AngleAxis静态方法:用一个向量乘一个四元数</font></strong></p>
<ul>
<li>AngleAxis静态方法用于将一个向量乘以一个四元数，相当于将那个向量按四元数的轴旋转了四元数的度数。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本挂载到立方体上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//用一个向量乘一个四元数 相当于把那个向量按四元数的轴旋转了四元数的度数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标：把指向z轴的向量连续往y轴转两次45度 最后会和x轴重合</span></span><br><span class="line"></span><br><span class="line">    Vector3 v = Vector3.forward;</span><br><span class="line">    print(v);<span class="comment">//(0.0, 0.0, 1.0)</span></span><br><span class="line"></span><br><span class="line">    v = Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up) * v;</span><br><span class="line">    print(v);<span class="comment">//(0.7, 0.0, 0.7)</span></span><br><span class="line"></span><br><span class="line">    v = Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up) * v;</span><br><span class="line">    print(v);<span class="comment">//(1.0, 0.0, 0.0)</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="练习题-8"><a href="#练习题-8" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.用目前所学知识，模拟飞机发射不同类型子弹的方法：单发，双发，扇形，环形</font></strong><br><strong><font size="3">声明发射类型枚举</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_FireType</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 单发</span></span><br><span class="line">    One,</span><br><span class="line">    <span class="comment">// 双发</span></span><br><span class="line">    Two,</span><br><span class="line">    <span class="comment">// 扇形</span></span><br><span class="line">    Three,</span><br><span class="line">    <span class="comment">// 环形</span></span><br><span class="line">    Round</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">创建飞机，创建飞机脚本，声明发射类型变量，把飞机脚本添加到飞机上</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 声明发射类型变量 </span></span><br><span class="line">    <span class="keyword">private</span> E_FireType nowType = E_FireType.One;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">飞机脚本 Update 内添加按按键切换发射类型逻辑</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.One;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Two;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Three;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Round;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">飞机脚本 Update 内添加按按键发射子弹逻辑</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Update 内添加按按键发射子弹逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        {</span><br><span class="line">            Fire();<span class="comment">//创建发射子弹函数</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">添加子弹预制体，声明子弹对象，拖拽赋值</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">添加子弹预制体，声明子弹对象，拖拽赋值</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子弹一直往前飞，五秒后销毁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">实现发子弹逻辑</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 开火方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span> (nowType)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> E_FireType.One:</span><br><span class="line">                <span class="comment">// 一个子弹直接创建在飞机当前位置和保持飞机当前旋转即可</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Two:</span><br><span class="line">                <span class="comment">// 两个子弹直接创建飞机当前位置左右各偏移一些和保持飞机当前旋转即可</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Three:</span><br><span class="line">                <span class="comment">// 一个子弹朝飞机自己的面朝向发射</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="comment">// 左边的子弹朝飞机自己左侧旋转 20 度再发射</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>, Vector3.up));</span><br><span class="line">                <span class="comment">// 右边的子弹朝飞机自己右侧旋转 20 度再发射</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Round:</span><br><span class="line">                <span class="comment">// 360 度除以你要发射多少子弹得到每个子弹偏移的角度 这样每转这个角度就发射一个子弹</span></span><br><span class="line">                <span class="built_in">float</span> angle = <span class="number">360f</span> / roundNum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 角度是当前偏移度数乘飞机自己的旋转</span></span><br><span class="line">                    Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<p><strong><font size="4">用所学3D数学知识实现摄像机跟随效果,摄像机在人物斜后方，通过角度控制倾斜率，通过鼠标滚轮可以控制摄像机距离人物的距离（有最大最小限制），摄像机看向人物头顶上方一个位置（可调节），Vector3.Lerp实现相机跟随人物，Quaternino.Slerp实现摄像机朝向过渡效果</font></strong></p>
<blockquote>
<p>对于前三点进行分析:<br>摄像机看向人物头顶上方一个位置（可调节）可以理解为当前对象的Vector3.up在乘一个头顶的标量系数，控制到底看头顶的哪里，称之为头顶向量。可以理解为看向头顶多高的位置。<br>像机在人物斜后方，通过角度控制倾斜率可以理解为对于在头顶向量终点乘一个四元数偏转一个角度，角度可以变化实现控制倾斜率<br>同时这个向量在乘一个标量大小实现控制摄像机距离人物的距离，通过鼠标滚轮控制</p>
</blockquote>
<p><strong><font size="3">创建摄像机移动脚本，挂载到摄像机上，声明必要的变量</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相对头顶的偏移位置 看向头顶多高的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> headOffsetH = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摄像机倾斜的角度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> offsetAngle = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的 摄像机离观测点的距离</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> cameraDis = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摄像机离观测点的距离必须是3和10之间</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> minDis = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> maxDis = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标中间滚动控制的移动速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> roundSpeed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看向对象时 四元数 旋转的速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> lookAtSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟随对象移动的 速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前摄像机应该在的位置</span></span><br><span class="line">Vector3 nowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头顶一个在的位置</span></span><br><span class="line">Vector3 headPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头顶位置指向摄像机的方向向量</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowDir;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Update 内实现摄像机相关逻辑</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//实现了鼠标中键 滚动 来改变摄像机远近</span></span><br><span class="line">        cameraDis += Input.GetAxis(<span class="string">"Mouse ScrollWheel"</span>) * roundSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加紧函数 取最大值和最小值之间的数</span></span><br><span class="line">        cameraDis = Mathf.Clamp(cameraDis, minDis, maxDis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向头顶偏移位置</span></span><br><span class="line">        headPos = target.position + target.up * headOffsetH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用要倾斜的角度和轴算出要旋转的四元数 乘上当前向后的向量 就能得到摄像机偏移角度后往后方偏移位置</span></span><br><span class="line">        <span class="comment">//通俗理解 nowDir就是头顶位置指向摄像机的方向向量</span></span><br><span class="line">        nowDir = Quaternion.AngleAxis(offsetAngle, target.right) * -target.forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用头顶位置加上要偏移的角度乘摄像机离观测点的距离 就是当前摄像机应该在的位置</span></span><br><span class="line">        nowPos = headPos + nowDir * cameraDis;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接把算出来的位置 进行赋值</span></span><br><span class="line">        <span class="comment">//this.transform.position = nowPos;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过插值运算缓慢移动相机位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = Vector3.Lerp(<span class="keyword">this</span>.transform.position, nowPos, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是通过插值运算来缓动看向物体</span></span><br><span class="line">        <span class="comment">//摄像机要看的是nowDir的反向向量 所以通过LookRotation算出旋转成的四元数 传入当做插值函数的终点</span></span><br><span class="line">        <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, Quaternion.LookRotation(-nowDir), Time.deltaTime * lookAtSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画出头顶和摄像机的连线</span></span><br><span class="line">        Debug.DrawLine(<span class="keyword">this</span>.transform.position, headPos);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">运行效果</font></strong></p>
<ul>
<li>0度和45度时</li>
</ul>
<h1 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h1><p><code>MonoBehavior中的重要内容-延迟函数</code></p>
<h2 id="延迟函数-详解"><a href="#延迟函数-详解" class="headerlink" title="延迟函数 详解"></a>延迟函数 详解</h2><p><strong><font size="4">什么是延迟函数:</font></strong></p>
<ul>
<li>延迟函数顾名思义：就是会延迟执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。它是MonoBehavior基类中实现好的方法。</li>
</ul>
<p><strong><font size="4">延迟函数的使用:</font></strong></p>
<p><strong><font size="3">Invoke方法:开始延迟函数</font></strong></p>
<ul>
<li>Invoke方法用于在指定时间后调用指定方法。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 在time秒后调用methodName方法。</span></span><br><span class="line">    <span class="comment">// 参数一：函数名字符串</span></span><br><span class="line">    <span class="comment">// 参数二：延迟时间，秒为单位</span></span><br><span class="line">    Invoke(<span class="string">"DelayDoSomething"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// - 延时函数第一个参数传入的是函数名字符串。即使填错了也不会报错。</span></span><br><span class="line">    <span class="comment">// - 延时函数无法传入参数。如果直接调用有参数的函数，会寻找没有参数的重载。</span></span><br><span class="line">    <span class="comment">// - 函数名必须是该脚本上声明的函数。如果想调用其他脚本的函数，也要包裹一层在这个脚本无参的函数里。</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayDoSomething</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"延时执行的函数"</span>);</span><br><span class="line"></span><br><span class="line">    TestFun(<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"传入参数"</span> + i);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">InvokeRepeating方法:开启延迟重复执行函数</font></strong></p>
<ul>
<li>InvokeRepeating方法用于在指定时间后开始重复调用指定方法。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 在time秒后调用methodName方法，然后每repeatRate秒调用一次。</span></span><br><span class="line">    <span class="comment">// 参数一：函数名字符串</span></span><br><span class="line">    <span class="comment">// 参数二：第一次执行的延迟时间</span></span><br><span class="line">    <span class="comment">// 参数三：之后每次执行的间隔时间</span></span><br><span class="line">    InvokeRepeating(<span class="string">"DelaRepeat"</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 注意：它的注意事项和延时函数一致</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelaRepeat</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"重复执行"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">CancelInvoke方法:取消延迟函数</font></strong></p>
<ul>
<li>CancelInvoke方法用于取消所有或者指定延迟函数的执行。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 不传入参数，取消该脚本上的所有延时函数执行</span></span><br><span class="line">    CancelInvoke();</span><br><span class="line">    <span class="comment">// 传入参数，取消指定延迟函数</span></span><br><span class="line">    <span class="comment">// 只要取消了指定延迟，不管之前该函数开启了多少次延迟执行，都会统一取消</span></span><br><span class="line">    CancelInvoke(<span class="string">"DelayDoSomething"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">IsInvoking方法:判断是否有延迟函数</font></strong></p>
<ul>
<li>IsInvoking方法用于判断是否存在待处理的指定方法调用。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 是否有任何待处理的methodName调用？</span></span><br><span class="line">    <span class="comment">// 不传入参数，判断该脚本上是否存在任何延迟函数</span></span><br><span class="line">    <span class="keyword">if</span> (IsInvoking())</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"存在延迟函数"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 传入参数，判断该脚本上是否存在指定延迟函数</span></span><br><span class="line">    <span class="keyword">if</span> (IsInvoking(<span class="string">"DelayDoSomething"</span>))</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"存在延迟函数DelayDoSomething"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">延迟函数受对象失活销毁影响:</font></strong></p>
<ul>
<li>延迟函数在对象失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 脚本依附对象失活或者脚本自己失活，延迟函数可以继续执行不受影响</span></span><br><span class="line"><span class="comment">// 脚本依附对象销毁或者脚本移除，延迟函数无法继续执行</span></span><br><span class="line"><span class="comment">// 如果需要在对象失活时停止延迟函数，可以在生命周期函数OnEnable和OnDisable中做逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 对象激活的生命周期函数中，开启延迟（重复执行的延迟）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 对象失活的生命周期函数中，停止延迟   </span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li>继承MonoBehavior的脚本可以使用延时相关函数。</li>
</ul>
<p><strong><font size="3">函数相关:</font></strong></p>
<ul>
<li>Invoke:延时函数</li>
<li>InvokeRepeating:延时重复函数</li>
<li>CancelInvoke:停止所以或者指定延时函数</li>
<li>IsInvoking:判断是否有延时函数待执行</li>
</ul>
<p><strong><font size="3">使用相关:</font></strong></p>
<ul>
<li>参数都是函数名，无法传参数</li>
<li>只能执行该脚本中申明的函数</li>
<li>对象或脚本失活无法停止延时函数执行，只有销毁组件或者对象才会停止或者代码停止</li>
</ul>
<h2 id="练习题-9"><a href="#练习题-9" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.利用延时函数实现一个计秒器</font></strong></p>
<details>
  <summary>查看答案</summary>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器</span></span><br><span class="line">    InvokeRepeating(<span class="string">"DelayTimer"</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己</span></span><br><span class="line">    DelayTimer2();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(time + <span class="string">"秒"</span>);</span><br><span class="line">    ++time;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer2</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(time + <span class="string">"秒"</span>);</span><br><span class="line">    ++time;</span><br><span class="line">    Invoke(<span class="string">"DelayTimer2"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</details>


<p><strong><font size="4">2.请用两种方式延时销毁一个指定对象</font></strong></p>
<details>
  <summary>查看答案</summary>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 通过Destroy来进行延迟销毁</span></span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟函数销毁，内部使用销毁逻辑，</span></span><br><span class="line">    <span class="comment">// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中</span></span><br><span class="line">    Invoke(<span class="string">"DelayDestroy"</span>, <span class="number">5</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayDestroy</span>()</span></span><br><span class="line">{</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>

<h1 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h1><p><code>MonoBehaviour中的重要内容-协同程序</code></p>
<p><strong><font size="4">Unity是否支持多线程:</font></strong></p>
<ul>
<li>Unity是支持多线程的，只是新开线程无法访问Unity相关对象的内容。例如this.transform。</li>
<li>注意：Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑</li>
<li>在Unity中，不会开启多线程访问Unity相关。当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//新线程</span></span><br><span class="line">Thread newThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西</span></span><br><span class="line">Queue&lt;Vector3&gt; queue = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//副线程可能也要拿主线程的数据用来判断做逻辑</span></span><br><span class="line">Queue&lt;Vector3&gt; queue2 = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//首先要明确一点</span></span><br><span class="line">    <span class="comment">//Unity是支持多线程的</span></span><br><span class="line">    <span class="comment">//只是新开线程无法访问Unity相关对象的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用System.Threading命名空间</span></span><br><span class="line">    newThread = <span class="keyword">new</span> Thread(newThreadLogic);</span><br><span class="line">    newThread.Start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//Unity中的多线程 要记住关闭</span></span><br><span class="line">    <span class="comment">//不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容</span></span><br><span class="line">    <span class="comment">//可以在OnDestroy执行关闭线程逻辑</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用</span></span><br><span class="line">    <span class="keyword">if</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//取出位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = queue.Dequeue();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//新线程逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThreadLogic</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        print(<span class="string">"新线程逻辑 每隔一秒的打印"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们在Unity中，不会开启多线程访问Unity相关</span></span><br><span class="line">        <span class="comment">//当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿</span></span><br><span class="line">        <span class="comment">//这时就可以开启多线程用于A星寻路算法，网络收发相关</span></span><br><span class="line">        <span class="comment">//当算好了结果或者收到了消息过后，放在公共的内存区域</span></span><br><span class="line">        <span class="comment">//主线程判断判断公共的内存区域有没有想要的对象，拿来使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这句代码会报错 不能在副线程控制Unity相关</span></span><br><span class="line">        <span class="comment">//UnityException: get_transform can only be called from the main thread.</span></span><br><span class="line">        <span class="comment">//this.transform.Translate(Vector3.forward * Time.deltaTime);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中</span></span><br><span class="line">        <span class="comment">//用Unity的随机数都不能用 用C#里的随机数</span></span><br><span class="line">        System.Random r = <span class="keyword">new</span> System.Random();</span><br><span class="line">        queue.Enqueue(<span class="keyword">new</span> Vector3(r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>)));</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//关闭线程</span></span><br><span class="line">    newThread.Abort();</span><br><span class="line">    <span class="comment">//关闭线程后置空</span></span><br><span class="line">    newThread = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">协同程序是什么？</font></strong></p>
<ul>
<li>协同程序简称协程</li>
<li>它是假的多线程，它不是多线程</li>
<li>它的本质是迭代器</li>
</ul>
<p><strong><font size="4">协程的主要作用:</font></strong></p>
<ul>
<li>将代码分时执行，不卡主线程</li>
<li>简单理解:是把可能会让主线程卡顿的耗时逻辑分时分步执行</li>
</ul>
<p><strong><font size="4">主要使用场景:</font></strong></p>
<ul>
<li>异步加载文件</li>
<li>异步下载文件</li>
<li>场景异步加载</li>
<li>批量创建时防止卡顿</li>
</ul>
<p><strong><font size="4">协同程序和线程的区别:</font></strong><br><strong><font size="3">新开一个线程是独立的一个管道，与主线程并行执行。</font></strong></p>
<p><strong><font size="3">新开一个携程是在原线程之上开启，进行逻辑分时分步执行。</font></strong></p>
<ul>
<li>可以理解为:在主线程开启了一个别的分支，将协程拆分成多部分按逻辑分时分布执行。</li>
<li>在一次主线程循环中，可能只执行了协程的某一部分。</li>
<li>根据返回的逻辑，决定下次执行时机。</li>
<li>未执行时，协程处于挂起状态，等待下次执行时继续执行后续部分。</li>
<li>直到协程的每一部分都执行完毕，这个协程才算执行完毕。</li>
</ul>
<p><strong><font size="3">协同程序和线程的区别通俗解释：</font></strong></p>
<ul>
<li>多线程如同两根管道。</li>
<li>协程是在线程上开启的一个分支，进行分时分步的执行。</li>
</ul>
<p><strong><font size="4">协程的使用:</font></strong></p>
<ul>
<li>继承MonoBehavior的类,都可以开启 协程函数</li>
</ul>
<p><strong><font size="3">声明协程函数:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//申明协程函数</span></span><br><span class="line"><span class="comment">//关键点一： 协同程序（协程）函数 返回值 必须是 IEnumerator或者继承它的类型 </span></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//关键点二： 协程函数当中 必须使用 yield return 进行返回</span></span><br><span class="line">    print(<span class="string">"传进来的int值"</span> + i);</span><br><span class="line">    print(<span class="string">"yield return 任意数字 或 yield return null"</span>);</span><br><span class="line">    print(<span class="string">"下一帧后在Update和LateUpdate之间再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"传进来的string值"</span> + str);</span><br><span class="line">    print(<span class="string">"yield return new WaitForSeconds(3f)"</span>);</span><br><span class="line">    print(<span class="string">"等待3秒后在Update和LateUpdate之间再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3f</span></span>)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">StartCoroutine方法:开启协程函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//协程函数 是不能够 直接这样去执行的！！！！！！！</span></span><br><span class="line">    <span class="comment">//直接这样调用函数执行没有任何效果</span></span><br><span class="line">    <span class="comment">//MyTimerCoroutine(1, "123");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoBehaviour中的StartCoroutine方法 开启协程</span></span><br><span class="line">    <span class="comment">//启动协程。</span></span><br><span class="line">    <span class="comment">//常用开启协程的方式</span></span><br><span class="line">    <span class="comment">//注意：StartCoroutine会返回一个Coroutine对象 可以用一个Coroutine变量装起来 可以用于指定协程的关闭</span></span><br><span class="line">    <span class="comment">//用迭代器接口变量接一个协程函数 在丢进StartCoroutine执行</span></span><br><span class="line">    IEnumerator ie = MyCoroutine(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">    Coroutine c1 = StartCoroutine(ie);</span><br><span class="line">    <span class="comment">//直接把协程函数丢进StartCoroutine执行</span></span><br><span class="line">    Coroutine c2 = StartCoroutine(MyCoroutine(<span class="number">2</span>, <span class="string">"222"</span>));</span><br><span class="line">    Coroutine c3= StartCoroutine(MyCoroutine(<span class="number">3</span>, <span class="string">"333"</span>));</span><br><span class="line">    Coroutine c4 = StartCoroutine(MyCoroutine(<span class="number">4</span>, <span class="string">"444"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：关闭协程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoBehaviour中的StopAllCoroutines方法 关闭所有协程</span></span><br><span class="line">    <span class="comment">//停止在该行为上运行的所有协同程序。</span></span><br><span class="line">    <span class="comment">//StopAllCoroutines();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoBehaviour中的StopCoroutine方法 关闭指定协程</span></span><br><span class="line">    <span class="comment">//停止在该行为上运行的第一个名为 methodName 的协同程序或存储在 routine 中的协同程序。</span></span><br><span class="line">    <span class="comment">//一般都通过关闭返回的协程对象进行关闭 不推荐传入字符串进行关闭</span></span><br><span class="line">    StopCoroutine(c2);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">StopCoroutine和StopAllCoroutines方法:关闭协程函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoBehaviour中的StopAllCoroutines方法 关闭所有协程</span></span><br><span class="line">    <span class="comment">//停止在该行为上运行的所有协同程序。</span></span><br><span class="line">    <span class="comment">//StopAllCoroutines();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MonoBehaviour中的StopCoroutine方法 关闭指定协程</span></span><br><span class="line">    <span class="comment">//停止在该行为上运行的第一个名为 methodName 的协同程序或存储在 routine 中的协同程序。</span></span><br><span class="line">    <span class="comment">//一般都通过关闭返回的协程对象进行关闭 不推荐传入字符串进行关闭</span></span><br><span class="line">    StopCoroutine(c2);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">yield return 不同内容的含义:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//1.下一帧执行</span></span><br><span class="line">    <span class="comment">//yield return 数字;</span></span><br><span class="line">    <span class="comment">//yield return null;</span></span><br><span class="line">    <span class="comment">//在Update和LateUpdate之间执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.等待指定秒后执行</span></span><br><span class="line">    <span class="comment">//yield return new WaitForSeconds(秒);</span></span><br><span class="line">    <span class="comment">//在Update和LateUpdate之间执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.等待下一个固定物理帧更新时执行</span></span><br><span class="line">    <span class="comment">//yield return new WaitForFixedUpdate();</span></span><br><span class="line">    <span class="comment">//在FixedUpdate和碰撞检测相关函数之后执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.等待摄像机和GUI渲染完成后执行</span></span><br><span class="line">    <span class="comment">//yield return new WaitForEndOfFrame();</span></span><br><span class="line">    <span class="comment">//在LateUpdate之后的渲染相关处理完毕后之后</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.一些特殊类型的对象 比如异步加载相关函数返回的对象</span></span><br><span class="line">    <span class="comment">//之后讲解 异步加载资源 异步加载场景 网络加载时再讲解</span></span><br><span class="line">    <span class="comment">//一般在Update和LateUpdate之间执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.跳出协程</span></span><br><span class="line">    <span class="comment">//yield break;</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"传进来的int值"</span> + i);</span><br><span class="line">    print(<span class="string">"yield return 任意数字 或 yield return null"</span>);</span><br><span class="line">    print(<span class="string">"下一帧后在Update和LateUpdate之间再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"传进来的string值"</span> + str);</span><br><span class="line">    print(<span class="string">"yield return new WaitForSeconds(3f)"</span>);</span><br><span class="line">    print(<span class="string">"等待3秒后在Update和LateUpdate之间再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3f</span></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"WaitForFixedUpdate()"</span>);</span><br><span class="line">    print(<span class="string">"等待下一个固定物理帧更新时再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"WaitForEndOfFrame()"</span>);</span><br><span class="line">    print(<span class="string">"等待摄像机和GUI渲染完成后再执行后面的逻辑"</span>);</span><br><span class="line">    <span class="comment">//主要会用来 截图时 会使用 截图一般是要渲染完再截图</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"跳出协程"</span>);</span><br><span class="line">    <span class="comment">//注意：直接跳出协程后再StopCoroutine(Coroutine协程对象)，会报错，跳出后代表这个协程已经结束了</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//协程函数是可以写死循环的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"死循环内 yield return new WaitForSeconds(5f);"</span>);</span><br><span class="line">        print(<span class="string">"死循环内 等待5秒后在Update和LateUpdate之间再执行后面的逻辑"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5f</span></span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">协程受对象和组件失活销毁的影响</font></strong></p>
<ul>
<li>协程开启后</li>
<li>组件或物体销毁,物体失活,则协程不再执行。</li>
<li>组件失活时,协程仍然执行。</li>
</ul>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容。一般主要用于进行复杂逻辑运算或者网络消息接收等等。注意：Unity中的多线程一定记住关闭，可以在OnDestroy关闭。</li>
<li>协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿。</li>
<li>继承MonoBehavior的类都可以使用协程。</li>
<li>开启协程方法、关闭协程方法。</li>
<li>yield return 返回的内容对于我们的意义。</li>
<li>协程只有当组件单独失活时不受影响，其它情况协程会停止。</li>
</ul>
<h2 id="练习题-10"><a href="#练习题-10" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.利用协程制作一个计秒器:</font></strong></p>
<details>
  <summary>查看答案</summary>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    StartCoroutine(MyTimerCoroutine());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我的计时器协程</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyTimerCoroutine</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计时死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"我的计时器"</span> + time + <span class="string">"秒"</span>);</span><br><span class="line">        ++time;</span><br><span class="line">        <span class="comment">// 每过一秒再执行</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</details>

<p><strong><font size="4">2.在场景中创建100000个随机位置的立方体，让其不会明显卡顿</font></strong></p>
<details>
  <summary>查看答案</summary>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    {</span><br><span class="line">        StartCoroutine(CreateCube(<span class="number">100000</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建立方体的协程函数</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">CreateCube</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    {</span><br><span class="line">        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">        obj.transform.position = <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 每创建1000个，就下一帧再创建，这样就没那么卡</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>
 


<h1 id="协同程序原理"><a href="#协同程序原理" class="headerlink" title="协同程序原理"></a>协同程序原理</h1><p><code>MonoBehaviour中的重要内容-协同程序原理</code></p>
<p><strong><font size="4">协程的本质:</font></strong><br><strong><font size="3">协程可以分成两部分:</font></strong></p>
<ul>
<li>协程函数本体</li>
<li>协程调度器</li>
<li>协程本体就是一个能够中间暂停返回的函数</li>
<li>协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数</li>
<li>Unity只实现了协程调度部分</li>
<li>协程的本体本质上就是一个 C#的迭代器方法</li>
</ul>
<p><strong><font size="3">通俗理解:</font></strong></p>
<ul>
<li>协程函数本体就是我们自己写的协程函数 这个要我们自己写逻辑</li>
<li>我们写的协程函数实际上是个迭代器方法</li>
<li>我们把我们写的协程函数丢到 MonoBehaviour中开启协程的方法 StartCoroutine 中</li>
<li>可以理解为 就是把一个迭代器方法的返回值 返回给Unity内部的一个协程管理器里面存储起来</li>
<li>通过协程管理器对应着我们写协程函数的逻辑和啥时候yield return 能在对应时机帮我们继续调用协程函数</li>
</ul>
<p><strong><font size="4">协程本体是迭代器方法的体现:</font></strong></p>
<p><strong><font size="3">测试类:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> testNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestClass</span>(<span class="params"><span class="built_in">int</span> testNum</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.testNum = testNum;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">声明迭代器函数:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//测试的迭代器（协程）函数</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Test</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"第一次执行"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    print(<span class="string">"第二次执行"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">    print(<span class="string">"第三次执行"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"666"</span>;</span><br><span class="line">    print(<span class="string">"第四次执行"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">TestClass</span>(<span class="params"><span class="number">250</span></span>)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">协程函数本体:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//如果我们不通过 开启协程方法执行协程 直接调用协程的话 没有作用</span></span><br><span class="line">    Test();<span class="comment">//没有作用</span></span><br><span class="line">    <span class="comment">//Unity的协程调度器是不会帮助我们管理协程函数的 我们可以用一个迭代器变量把我们的协程函数装起来</span></span><br><span class="line">    IEnumerator ieTest = Test();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/但是我们可以自己执行手动迭代器函数内容</span></span><br><span class="line">    <span class="comment">//ieTest.MoveNext();//第一次执行</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/会执行函数中内容遇到 yield return为止的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//print(ieTest.Current);//1</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/得到 yield return 返回的内容 这个Current是Object类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ieTest.MoveNext();//第二次执行</span></span><br><span class="line">    <span class="comment">//print(ieTest.Current);//999</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ieTest.MoveNext();//第三次执行</span></span><br><span class="line">    <span class="comment">//print(ieTest.Current);//666</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ieTest.MoveNext();//第四次执行</span></span><br><span class="line">    <span class="comment">//TestClass tc = ieTest.Current as TestClass;//可以把Current对象as成对应的类</span></span><br><span class="line">    <span class="comment">//print(tc.testNum);//250</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/MonoBehaviour中开启协程的方法StartCoroutine</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/其实就是得到我们的迭代器对象 再根据Unity自己的规则一步一步的执行协程函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/像上面这样一步一步写其实不太好 写把上面的注释了 用while逐个执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MoveNext 代表执行下一个yield return之前的逻辑 并且有返回值 返回值代表着字符迭代器是否到了结尾（这个迭代器函数 是否执行完毕）</span></span><br><span class="line">    <span class="keyword">while</span> (ieTest.MoveNext())</span><br><span class="line">    {</span><br><span class="line">        print(ieTest.Current);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">协程调度器:</font></strong><br><strong><font size="3">继承MonoBehavior后 开启协程:</font></strong></p>
<ul>
<li>相当于是把一个协程函数（迭代器）放入Unity的协程调度器中帮助我们管理进行执行</li>
<li>具体的yield return 后面的规则 也是Unity定义的一些规则</li>
</ul>
<p><strong><font size="3">协程本体是迭代器方法的体现总结:</font></strong></p>
<ul>
<li>你可以简化理解迭代器函数</li>
<li>C#看到迭代器函数和yield return语法糖</li>
<li>就会把原本是一个的函数变成”几部分”</li>
<li>我们可以通过迭代器 从上到下遍历这 “几部分” 进行执行</li>
<li>就达到了将一个函数中的逻辑分时执行的目的</li>
</ul>
<p><strong><font size="3">而协程调度器就是 利用迭代器函数返回的内容来进行之后的处理:</font></strong></p>
<ul>
<li>比如Unity中的协程调度器</li>
<li>根据yield return返回的内容 决定了下一次在何时继续执行迭代器函数中的”下一部分”</li>
</ul>
<p><strong><font size="3">理论上来说 我们可以利用迭代器函数的特点 自己实现协程调度器来取代Unity自带的调度器</font></strong></p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="3">协程的本质 就是：</font></strong></p>
<ul>
<li>利用C#的迭代器函数”分步执行”的特点</li>
<li>加上 Unity自己定义的一些协程调度逻辑</li>
<li>实现的一套分时执行函数的规则</li>
</ul>
<h2 id="练习题-11"><a href="#练习题-11" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.请不使用Unity自带的协程协调器开启协程，通过迭代器函数实现每隔一秒执行函数中的一部分逻辑</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>声明一个协程函数</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">MyTestCoroutine</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">// 如果是用Unity自带的协程协调器开启协程 那么数字代表等待1帧继续执行之后的内容</span></span><br><span class="line">    <span class="comment">// 如果是自己的协程协调器可以自己自定义规则</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    print(<span class="string">"2"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    print(<span class="string">"3"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    print(<span class="string">"4"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>声明用于记录当前协程函数和返回时间的类</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于记录当前协程函数和返回时间的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NowIEnumeratorAndYieldReturnTime</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//记录 下次还要执行的 迭代器接口</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerator ie;</span><br><span class="line">    <span class="comment">//记录 下次执行的时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>声明自己写的协程管理器，搞成单例，创建开启协程方法，声明用于记录当前协程函数和返回时间的类，在声明这个类的容器，最后实现Update里判断时间的逻辑。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我的协程管理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCoroutineMgr</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyCoroutineMgr instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyCoroutineMgr Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明存储 迭代器函数对象的 容器 用于 一会继续执行</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;NowIEnumeratorAndYieldReturnTime&gt; list = <span class="keyword">new</span> List&lt;NowIEnumeratorAndYieldReturnTime&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    {</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我的开启协程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyStartCoroutine</span>(<span class="params">IEnumerator ie</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//来进行 分步走 分时间执行的逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入一个 迭代器函数返回的接口 那么应该一来就执行它</span></span><br><span class="line">        <span class="comment">//一来就先执行第一步 执行完了 如果返回的true 证明 后面还有步骤</span></span><br><span class="line">        <span class="keyword">if</span>(ie.MoveNext())</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//判断 如果yield return返回的是 数字 是一个int类型 那就证明 是需要等待n秒继续执行</span></span><br><span class="line">            <span class="keyword">if</span>(ie.Current <span class="keyword">is</span> <span class="built_in">int</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//进来这里说明yield return返回已经是int类型了 按我们自己的规则要过一会执行协程</span></span><br><span class="line">                <span class="comment">//按思路 应该把 这个迭代器函数 和它下一次执行的时间点 记录下来</span></span><br><span class="line">                <span class="comment">//然后不停检测 时间 是否到达了 下一次执行的 时间点 然后就继续执行它</span></span><br><span class="line">                <span class="comment">//这样我们不妨声明一个类</span></span><br><span class="line">                <span class="comment">//这个类的数据结构是有一个IEnumerator变量用于存储协程函数和float变量用于存储协程要执行的时间</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建协程存储类</span></span><br><span class="line">                NowIEnumeratorAndYieldReturnTime nowIEAndTime = <span class="keyword">new</span> NowIEnumeratorAndYieldReturnTime();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录迭代器接口</span></span><br><span class="line">                nowIEAndTime.ie = ie;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录迭代器要执行的时间</span></span><br><span class="line">                nowIEAndTime.time = Time.time + (<span class="built_in">int</span>)ie.Current;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把记录的信息 记录到数据容器当中 因为可能有多个协程函数 开启 所以 用一个 list来存储</span></span><br><span class="line">                list.Add(nowIEAndTime);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//为了避免在循环的时候 从列表里面移除内容 我们可以倒着遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = list.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//判断 当前该迭代器函数 是否到了下一次要执行的时间</span></span><br><span class="line">            <span class="comment">//如果到了 就需要执行下一步了</span></span><br><span class="line">            <span class="keyword">if</span>( list[i].time &lt;= Time.time  )</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//判断还能不能往后继续执行</span></span><br><span class="line">                <span class="comment">//注意：只要调用了MoveNext其实就执行了yield return之前的逻辑 只不过假如没有yield return就返回false</span></span><br><span class="line">                <span class="keyword">if</span> (list[i].ie.MoveNext())</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//如果是true 那还需要对该迭代器函数 进行处理</span></span><br><span class="line">                    <span class="comment">//如果是 int类型 证明是按秒等待</span></span><br><span class="line">                    <span class="keyword">if</span>(list[i].ie.Current <span class="keyword">is</span> <span class="built_in">int</span>)</span><br><span class="line">                    {</span><br><span class="line">                        list[i].time = Time.time + (<span class="built_in">int</span>)list[i].ie.Current;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果不是int类型 是别的类型 可以自己加if else 判断是啥类型 可能要声明新的容器存进去 这里就不写了</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//该list 只是存储 处理时间相关 等待逻辑的 迭代器函数的 </span></span><br><span class="line">                        <span class="comment">//如果是别的类型 就不应该 存在这个list中 应该根据类型把它放入别的容器中</span></span><br><span class="line">                        list.RemoveAt(i);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//后面已经没有可以等待和执行的了 证明已经执行完毕了逻辑</span></span><br><span class="line">                    list.RemoveAt(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>


<h1 id="Unity中的特殊文件夹"><a href="#Unity中的特殊文件夹" class="headerlink" title="Unity中的特殊文件夹"></a>Unity中的特殊文件夹</h1><p><code>Resources资源动态加载-Unity中特殊文件夹</code></p>
<p><strong><font size="4">Application.dataPath 工程路径获取:</font></strong></p>
<p><strong><font size="3">Application类中的dataPath静态变量 获取工程路径</font></strong></p>
<ul>
<li>包含目标设备上的游戏数据文件夹路径（只读）。</li>
<li>注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用</li>
<li>我们不会在实际发布游戏后 还使用该路径</li>
<li>print(Application.dataPath);</li>
</ul>
<p><strong><font size="4">Resources 资源文件夹:</font></strong></p>
<ul>
<li><p>需要我们自己手动在Asset文件下创建Resources文件夹 名字一定不要错</p>
</li>
<li><p>路径获取：一般不获取</p>
</li>
<li><p>只能使用Resources相关API进行加载</p>
</li>
<li><p>如果硬要获取 可以用工程路径拼接</p>
</li>
<li><p>print(Application.dataPath + “/Resources”);</p>
</li>
<li><p>创建：Resources文件夹需要我们自己创建</p>
</li>
<li><p>作用：资源文件夹</p>
</li>
<li><p>需要通过Resources相关API动态加载的资源需要放在其中</p>
</li>
<li><p>该文件夹下所有文件都会被打包出去</p>
</li>
<li><p>打包时Unity会对其压缩加密 所以一般不会用Application.dataPath + “/Resources” 得到路径</p>
</li>
<li><p>该文件夹打包后只读 只能通过Resources相关API加载</p>
</li>
</ul>
<blockquote>
<p>注意：不要把所有游戏资源都丢进去 一般放在美术资源文件夹就行了 需要动态加载或者打包的再丢进去</p>
</blockquote>
<p><strong><font size="4">Application.StreamingAssets 流动资源文件夹</font></strong></p>
<ul>
<li>需要我们自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错</li>
<li>Application类中的streamingAssetsPath静态变量 获取流动资源文件夹路径</li>
<li>StreamingAssets 文件夹的路径（只读）。</li>
<li>路径获取：print(Application.streamingAssetsPath);</li>
<li>创建：StreamingAssets文件夹需要我们自己创建</li>
<li>作用：流文件夹</li>
<li>打包出去不会被压缩加密，可以任由我们摆布</li>
<li>移动平台只读，PC平台可读可写</li>
<li>可以放入一些需要自定义动态加载的初始资源</li>
</ul>
<p><strong><font size="4">Application.persistentDataPath 持久数据文件夹</font></strong></p>
<ul>
<li>Application类中的persistentDataPath静态变量 获取持久数据文件夹路径</li>
<li>包含持久数据目录的路径（只读）。</li>
<li>路径获取：print(Application.persistentDataPath);</li>
<li>注意：不需要我们自己将创建</li>
<li>作用：固定数据文件夹</li>
<li>所有平台都可读可写</li>
<li>一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中</li>
<li>比如游戏进行时要存数据文件，或者要热更新，就可以存到这个文件夹下</li>
<li>Resources和StreamingAssets都是只读的</li>
</ul>
<p><strong><font size="4">Plugins 插件文件夹</font></strong></p>
<ul>
<li>需要我们自己手动在Asset文件下创建Plugins文件夹 名字一定不要错</li>
<li>注意：需要我们自己创建</li>
<li>作用：插件文件夹</li>
<li>不同平台的插件相关文件放在其中</li>
<li>比如IOS和Android平台 可能需要对应平台提供的代码包才能在Unity使用</li>
<li>以后搞SDK相关的时候可能才用得到</li>
</ul>
<p><strong><font size="4">Editor 编辑器文件夹</font></strong></p>
<ul>
<li>需要我们自己手动在Asset文件下创建Editor文件夹 名字一定不要错</li>
<li>路径获取：一般不获取</li>
<li>如果硬要获取 可以用工程路径拼接</li>
<li>print(Application.dataPath + “/Editor”);</li>
<li>注意：需要我们自己将创建</li>
<li>作用：编辑器文件夹</li>
<li>开发Unity编辑器时，编辑器相关脚本放在该文件夹中</li>
<li>该文件夹中内容不会被打包出去</li>
</ul>
<p><strong><font size="4">Standard Assets 默认资源文件夹</font></strong></p>
<ul>
<li>需要我们自己手动在Asset文件下创建Standard Assets文件夹 名字一定不要错</li>
<li>注意：需要我们自己将创建</li>
<li>作用：默认资源文件夹</li>
<li>一般Unity自带资源都放在这个文件夹下</li>
<li>代码和资源优先被编译</li>
</ul>
<h1 id="Resources同步加载"><a href="#Resources同步加载" class="headerlink" title="Resources同步加载"></a>Resources同步加载</h1><p><code>Resources资源动态加载-Resources同步加载</code></p>
<p><strong><font size="4">Resources资源动态加载的作用:</font></strong></p>
<ul>
<li>通过代码动态加载Resources文件夹下指定路径资源</li>
<li>避免繁琐的拖曳操作</li>
</ul>
<p><strong><font size="4">常用资源类型:</font></strong></p>
<ul>
<li>预设体对象——GameObject</li>
<li>音效文件——AudioClip</li>
<li>文本文件——TextAsset</li>
<li>图片文件——Texture</li>
<li>其它类型——需要什么用什么类型</li>
</ul>
<p><strong><font size="3">注意：</font></strong></p>
<ul>
<li>预设体对象加载需要实例化。</li>
<li>其它资源加载一般直接用。</li>
</ul>
<p><strong><font size="4">Resources.Load静态方法:资源同步加载普通方法</font></strong></p>
<ul>
<li>在一个工程当中 Resources文件夹 可以有多个，通过API加载时，它会自己去这些同名的Resources文件夹中去找资源。</li>
<li>打包时Resources文件夹里的内容都会打包在一起。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD_%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" class="" title="Resources文件夹里的内容" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="3">预设体对象:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要创建在场景上 记住实例化</span></span><br><span class="line">    <span class="comment">//第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) 但是并没有创建在场景中</span></span><br><span class="line">    Object obj = Resources.Load(<span class="string">"Cube"</span>);</span><br><span class="line">    <span class="comment">//第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化</span></span><br><span class="line">    Instantiate(obj);</span><br><span class="line">    <span class="comment">//第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) 但是并没有创建在场景中</span></span><br><span class="line">    Object obj2 = Resources.Load(<span class="string">"Sphere"</span>);</span><br><span class="line">    <span class="comment">//第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化</span></span><br><span class="line">    Instantiate(obj2);</span><br><span class="line">    <span class="comment">//注意：Resources文件夹就算不是直接是Assets文件夹的子文件夹，是孙子文件夹或者更深一层，里面的资源也能被加载出来</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">音效资源:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：就是加载数据</span></span><br><span class="line">    <span class="comment">//注意：子文件夹一层一层用/隔开</span></span><br><span class="line">    Object obj3 = Resources.Load(<span class="string">"Music/BKMusic"</span>);</span><br><span class="line">    <span class="comment">//第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可</span></span><br><span class="line">    <span class="comment">//需要把加载出来的数据as成音频传到音频源</span></span><br><span class="line">    audioSource.clip = obj3 <span class="keyword">as</span> AudioClip;</span><br><span class="line">    audioSource.Play();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">文本资源:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文本资源支持的格式</span></span><br><span class="line">    <span class="comment">//.txt</span></span><br><span class="line">    <span class="comment">//.xml</span></span><br><span class="line">    <span class="comment">//.bytes</span></span><br><span class="line">    <span class="comment">//.json</span></span><br><span class="line">    <span class="comment">//.html</span></span><br><span class="line">    <span class="comment">//.csv</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//需要把加载出来的文本资源as成文本资源 装起来就能打印了</span></span><br><span class="line">    TextAsset ta = Resources.Load(<span class="string">"Txt/Test"</span>) <span class="keyword">as</span> TextAsset;</span><br><span class="line">    <span class="comment">//文本内容</span></span><br><span class="line">    print(ta.text);</span><br><span class="line">    <span class="comment">//字节数据组</span></span><br><span class="line">    print(ta.bytes);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">图片:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Texture tex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 把图片as成Texture，可以在GUI里绘制图片测试</span></span><br><span class="line">     tex = Resources.Load(<span class="string">"Tex/TestJPG"</span>) <span class="keyword">as</span> Texture;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">{</span><br><span class="line">    GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), tex);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">其他类型:</font></strong></p>
<ul>
<li>需要什么类型，就用什么类型就行。</li>
</ul>
<p><strong><font size="4">问题：资源同名怎么办</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Texture tex;</span><br><span class="line"><span class="keyword">private</span> TextAsset ta;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Resources.Load加载同名资源时 无法准确加载出你想要的内容</span></span><br><span class="line">    <span class="comment">//可以使用Load方法的重载，第二个参数传入加载的指定类型的资源</span></span><br><span class="line">    <span class="comment">//加载指定类型的资源</span></span><br><span class="line">    tex = Resources.Load(<span class="string">"Tex/TestJPG"</span>, <span class="keyword">typeof</span>(Texture)) <span class="keyword">as</span> Texture;</span><br><span class="line">    ta = Resources.Load(<span class="string">"Tex/TestJPG"</span>, <span class="keyword">typeof</span>(TextAsset)) <span class="keyword">as</span> TextAsset;</span><br><span class="line">    print(ta.text);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">Resources.LoadAll静态方法:资源同步加载文件夹中指定名字的所有类型的资源方法</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Resources中的LoadAll静态方法 加载文件夹中指定名字的所有类型的资源</span></span><br><span class="line">    <span class="comment">//加载位于 Resources 文件夹中的 path 处的文件夹中的所有资源，或加载位于该处的文件。</span></span><br><span class="line">    <span class="comment">//加载指定名字的所有资源</span></span><br><span class="line">    Object[] objs = Resources.LoadAll(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Object item <span class="keyword">in</span> objs)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">is</span> Texture)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"这是图片"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> TextAsset)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"这是文本"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">Resources.Load<t>静态方法:资源同步加载泛型方法</t></font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Resources中的Load静态方法 可以用泛型方法加载资源 就不用as了</span></span><br><span class="line">    <span class="comment">//加载存储在 Resources 文件夹中的 path 处的资源。</span></span><br><span class="line">    TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">    print(ta2.text);</span><br><span class="line">    tex = Resources.Load&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Resources动态加载资源的方法。</li>
<li>让拓展性更强。</li>
<li>相对拖曳来说，它更加一劳永逸，更加方便。</li>
</ul>
<p><strong><font size="3">重要知识点：</font></strong></p>
<ul>
<li>记住API。</li>
<li>记住一些特定的格式。</li>
<li>预设体加载出来一定要实例化。</li>
</ul>
<h2 id="练习题-12"><a href="#练习题-12" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.请把之前四元数练习题中，发射散弹等相关逻辑改为动态加载资源并创建</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>把子弹丢到Resources文件夹后，有两种改法</li>
</ul>
<p><strong><font size="3">1.1.第一种是不在Inspector窗口拖拽Prefab，直接在Start()里Load，实例化的时候直接使用即可</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接在Start()里load加载</span></span><br><span class="line"><span class="keyword">private</span> GameObject Bullet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Bullet = Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">1.2.第二种是在实例化的时候每次都Resources.Load(“Bullet”)</font></strong></p>
<blockquote>
<p>注意：这样不会造成内存上的浪费，因为Unity加载好的资源放在缓存区，判断Load过了就不重新Load了，但是会造成性能开销</p>
</blockquote>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> (nowType)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 每次实例化的时候都Load，当其实Load了一次不会再Load</span></span><br><span class="line">        <span class="keyword">case</span> E_FireType.One:</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> E_FireType.Two:</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> E_FireType.Three:</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>, Vector3.up));</span><br><span class="line">            Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> E_FireType.Round:</span><br><span class="line">            <span class="built_in">float</span> angle = <span class="number">360</span> / roundNum;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)</span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">"Bullet"</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">调入函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">     <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.One;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Two;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Three;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))</span><br><span class="line">        {</span><br><span class="line">            nowType = E_FireType.Round;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        {</span><br><span class="line">            Fire();</span><br><span class="line">        } </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">运行效果</font></strong></p>
</details>


<h1 id="Resources异步加载"><a href="#Resources异步加载" class="headerlink" title="Resources异步加载"></a>Resources异步加载</h1><p><code>Resources资源动态加载-Resources异步加载</code></p>
<p><strong><font size="4">Resources异步加载是什么？</font></strong></p>
<ul>
<li>在上节课学习的同步加载中，如果我们加载过大的资源可能会造成程序卡顿。</li>
<li>卡顿的原因是从硬盘上把数据读取到内存中是需要进行计算的，越大的资源耗时越长，就会造成掉帧卡顿。</li>
<li>Resources异步加载就是内部新开一个线程进行资源加载，不会造成主线程卡顿。</li>
<li>其基本工作流程是主线程通知新线程要加载哪些资源，新线程加载完了放到公共内存区域，主线程检测到加载完毕取出来使用。</li>
<li>异步加载的缺点是：同步加载加载完直接拿来用，异步加载要等待加载完毕才能用</li>
<li>异步加载的优点是：能解决卡顿问题。</li>
</ul>
<p><strong><font size="4">Resources异步加载方法:</font></strong><br><strong><font size="3">Resources.LoadAsync<t>静态方法 异步加载</t></font></strong></p>
<ul>
<li>注意：异步加载 不能马上得到加载的资源 至少要等一帧</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD_%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" class="" title="Resources文件夹里的内容" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Resources中的LoadAsync方法 通过异步加载中的完成事件监听 使用加载的资源</span></span><br><span class="line">    <span class="comment">//异步加载存储在 Resources 文件夹中的 path 处的资源。</span></span><br><span class="line">    <span class="comment">//这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载</span></span><br><span class="line">    <span class="comment">//异步加载会有一个ResourceRequest类的返回值 用个变量接一下</span></span><br><span class="line">    <span class="comment">//ResourceRequest类是来自 Resources 包的异步加载请求。里面包含异步加载是否完成，进度这些变量，辅助做逻辑</span></span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">异步加载结束后做逻辑:</font></strong></p>
<p><strong><font size="3">方法一：添加异步加载完成回调函数</font></strong></p>
<p><strong><font size="3">ResourceRequest.completed 异步加载完成回调</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//怎么在异步加载结束后做逻辑了？主要有两种方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ResourceRequest这个类异步加载完成的回调</span></span><br><span class="line">    <span class="comment">//ResourceRequest这个类存在完成异步加载的事件回调</span></span><br><span class="line">    <span class="comment">//当异步加载结束时 马上进行一个资源下载结束的一个事件函数监听回调</span></span><br><span class="line">    <span class="comment">//注意：completed这个事件有一个AsyncOperation类型的参数</span></span><br><span class="line">    <span class="comment">//AsyncOperation类型是ResourceRequest类型的父类 一般是要把AsyncOperation类型as成ResourceRequest类型再获取ResourceRequest相关</span></span><br><span class="line">    resourceRequest.completed += AsynLoadOver;</span><br><span class="line">    <span class="comment">//打印帧数</span></span><br><span class="line">    print(<span class="string">"直接异步加载"</span>+Time.frameCount);</span><br><span class="line">    <span class="comment">//这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 不能直接使用资源 </span></span><br><span class="line">    <span class="comment">//一定要等加载结束过后 才能使用</span></span><br><span class="line">    <span class="comment">//resourceRequest.asset //错误用法</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">ResourceRequest.asset 异步加载得到的资源</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//异步加载结束事件监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AsynLoadOver</span>(<span class="params">AsyncOperation asyncOperationq</span>)</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"异步加载结束"</span>);</span><br><span class="line">    <span class="comment">//asset 是AsyncOperation类中的资源对象 加载完毕过后 就能够得到它</span></span><br><span class="line">    tex = (asyncOperationq <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> Texture;</span><br><span class="line">    <span class="comment">//得到后可以在OnGUI中画出这个图片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印帧数</span></span><br><span class="line">    print(<span class="string">"直接异步加载"</span> + Time.frameCount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">方法二：使用协程函数异步加载</font></strong></p>
<ul>
<li>开启异步加载协程函数</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//通过协程 异步加载的资源并写加载完之后的逻辑</span></span><br><span class="line">    StartCoroutine(CoroutineAsynLoad());</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>异步加载协程内使用ResourceRequest对象做逻辑</li>
<li>yield return resourceRequest 资源加载完毕再执行后面的代码</li>
<li>ResourceRequest.isDone 判断资源是否加载结束</li>
<li>ResourceRequest.progress 当前加载进度</li>
<li>异步加载协程函数代码</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//协程函数异步加载</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">CoroutineAsynLoad</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//开启协程就异步加载</span></span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">    print(<span class="string">"协程函数异步加载"</span> + Time.frameCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一：直接 yield returnResourceRequest类对象 加载完再写逻辑</span></span><br><span class="line">    <span class="comment">//当yield return的是ResourceRequest这个类的时候 </span></span><br><span class="line">    <span class="comment">//Unity的协程管理器就自己知道这个类的返回值 意味着你在异步加载资源 </span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> resourceRequest;</span><br><span class="line">    <span class="comment">//Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码</span></span><br><span class="line">    print(<span class="string">"协程函数异步加载结束"</span> + Time.frameCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：通过ResourceRequest中的变量判断当前加载情况 加载完再写逻辑</span></span><br><span class="line">    <span class="comment">//ResourceRequest中isDone变量 判断资源是否加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!resourceRequest.isDone)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//ResourceRequest中priority变量 当前的加载进度 </span></span><br><span class="line">        <span class="comment">//该进度 不会特别准确 过渡也不是特别明显</span></span><br><span class="line">        print(resourceRequest.progress);<span class="comment">//打印当前加载进度</span></span><br><span class="line">        <span class="comment">//每结束就下一帧再判断一次</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//直到结束了赋值给图片</span></span><br><span class="line">    tex = resourceRequest.asset <span class="keyword">as</span> Texture;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="3">1.完成事件监听异步加载：</font></strong></p>
<ul>
<li>好处：写法简单。</li>
<li>坏处：只能在资源加载结束后进行处理，是一种”线性加载”。</li>
<li>假如一个模型要加载三个资源，那么在这三个资源的完成异步加载回调里都要判断其他两个资源是否加载完。</li>
</ul>
<p><strong><font size="3">2.协程异步加载：</font></strong></p>
<ul>
<li>好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新。</li>
<li>坏处：写法稍麻烦，是一种”并行加载”。</li>
<li>假如一个模型要加载三个资源，可以直接在协程开启三个异步加载，用isDone并起来判断是否都加载完就行。</li>
</ul>
<p><strong><font size="3">注意：</font></strong></p>
<ul>
<li>理解为什么异步加载不能马上加载结束，为什么至少要等1帧。</li>
<li>理解协程异步加载的原理。</li>
</ul>
<h2 id="练习题-13"><a href="#练习题-13" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.请写一个简单的资源管理器，提供统一的方法给外部用于资源异步加载，外部可以传入委托用于当资源加载结束时使用资源</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">创建资源管理器，实现单例</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourcesMgr</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourcesMgr instance = <span class="keyword">new</span> ResourcesMgr();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResourcesMgr Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourcesMgr</span>()</span></span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">创建异步加载资源的泛型封装方法并实现，添加泛型约束，并假如一个字典来进行优化，假如重复加载的对象就重新加载了，直接回调</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录已经加载的资源</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, Object&gt; loadedAssets = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 异步加载指定名称的资源，并在加载完成后使用回调方法处理资源。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name="T"&gt;</span>要加载的资源类型（必须是Object的子类）。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="assetPath"&gt;</span>资源的名称或路径。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="callBack"&gt;</span>资源加载完成后的回调函数，其中参数为加载得到的资源对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadAssetAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> assetPath, UnityAction&lt;T&gt; callBack</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 如果存在这个key，直接拿来用</span></span><br><span class="line">    <span class="keyword">if</span> (loadedAssets.ContainsKey(assetPath))</span><br><span class="line">    {</span><br><span class="line">        Debug.Log(<span class="string">"资源已经被加载过了，直接使用已经加载的资源进行回调"</span>);</span><br><span class="line">        <span class="comment">// 资源已经被加载过了，直接使用已经加载的资源进行回调</span></span><br><span class="line">        <span class="comment">// 如果资源已经被加载过了，则直接从已加载资源字典中取得</span></span><br><span class="line">        Object obj = loadedAssets[assetPath];</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">        {</span><br><span class="line">            callBack(obj <span class="keyword">as</span> T);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步加载资源</span></span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;T&gt;(assetPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步加载完成回调</span></span><br><span class="line">    resourceRequest.completed += (asyncOperation) =&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 直接得到传入的对象，通过它得到资源内容，然后转换成对应类型传出去，外面不需要转换，直接使用</span></span><br><span class="line">        <span class="comment">// 获取加载完成得到的资源，asyncOperation类as成ResourceRequest在使用相关asset</span></span><br><span class="line">        Object asset = (asyncOperation <span class="keyword">as</span> ResourceRequest).asset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将资源添加到已加载资源字典中，便于后续复用</span></span><br><span class="line">        <span class="keyword">if</span> (!loadedAssets.ContainsKey(assetPath))</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 将加载得到的资源添加到已加载资源字典中</span></span><br><span class="line">            loadedAssets.Add(assetPath, asset);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数，并将加载得到的资源对象作为参数传入</span></span><br><span class="line">        callBack(asset <span class="keyword">as</span> T);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">调用封装的方法加载图片，并写一个延迟函数延迟重复加载，它就不会重新Load了</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD_%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" class="" title="Resources文件夹里的内容" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Texture tex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 调用自己封装的异步加载方法</span></span><br><span class="line">    ResourcesMgr.Instance.LoadAssetAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>, (obj) =&gt;</span><br><span class="line">    {</span><br><span class="line">        tex = obj;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟加载已经Load过的图片</span></span><br><span class="line">    Invoke(<span class="string">"DelayLoadTestJPG"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不封装的情况</span></span><br><span class="line">    ResourceRequest resourceRequest = Resources.LoadAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">    resourceRequest.completed += (asyncOperation) =&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// AsyncOperation as成 ResourceRequest在使用</span></span><br><span class="line">        tex = (asyncOperation <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> Texture;</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (tex != <span class="literal">null</span>)</span><br><span class="line">        GUI.DrawTexture(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), tex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelayLoadTestJPG</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 重复调用自己封装的异步加载方法，会判断是否加载过，加载过就不异步加载了</span></span><br><span class="line">    ResourcesMgr.Instance.LoadAssetAsync&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>, (obj) =&gt;</span><br><span class="line">    {</span><br><span class="line">        tex = obj;</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


</details>

















































































































































































































<h1 id="Resources卸载资源"><a href="#Resources卸载资源" class="headerlink" title="Resources卸载资源"></a>Resources卸载资源</h1><p><code>Resources资源动态加载-Resources卸载资源</code></p>
<p><strong><font size="4">Resources重复加载资源会浪费内存吗？</font></strong></p>
<ul>
<li>其实Resources加载一次资源过后</li>
<li>该资源就一直存放在内存中作为缓存</li>
<li>第二次加载时发现缓存中存在该资源</li>
<li>会直接取出来进行使用</li>
<li>所以，多次重复加载不会浪费内存</li>
<li>但是会浪费性能（每次加载都会去查找取出，始终伴随一些性能消耗）</li>
</ul>
<p><strong><font size="4">手动释放掉缓存中的资源:</font></strong></p>
<p><strong><font size="3">Resources中的UnloadAsset方法:</font></strong></p>
<ul>
<li>卸载指定资源</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中卸载 / assetToUnload /</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//该方法 不能释放 GameObject对象 因为它会用于实例化对象</span></span><br><span class="line"><span class="comment">//它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等</span></span><br><span class="line"><span class="comment">//一般情况下 我们很少单独使用它</span></span><br><span class="line"><span class="comment">//GameObject obj = Resources.CoroutineAsynLoad&lt;GameObject&gt;("Cube")</span></span><br><span class="line"><span class="comment">//即使是没有实例化的 GameObject对象也不能进行卸载</span></span><br><span class="line"><span class="comment">//Resources.UnloadAsset(obj);//报错 不能卸载GameObject</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Resources中的UnloadUnusedAssets方法:</font></strong></p>
<ul>
<li>卸载未使用的资源</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卸载未使用的资源。</span></span><br><span class="line"><span class="comment">//注意：一般在过场景时和GC一起使用</span></span><br><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line">GC.Collect();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">运行实测:</font></strong></p>
<ul>
<li>打开调试窗口，按下按键，可以查看加载图片和卸载图片内存的变化，重复按下加载，内存还是不会变化</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%8D%B8%E8%BD%BD_Profiler.png" class="" title="打开Profiler窗口" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%8D%B8%E8%BD%BD_Profiler%E7%AA%97%E5%8F%A3.png" class="" title="Profiler窗口" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<blockquote>
<p>由于Unity版本差异 Profiler窗口 在window里的位置可能不一样 可以使用快捷键 Ctrl+7;</p>
</blockquote>
<p><strong><font size="3">创建脚本并编写测试代码</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Texture tex;</span><br><span class="line"><span class="keyword">public</span> Button m_button_1;<span class="comment">//加载按钮</span></span><br><span class="line"><span class="keyword">public</span> Button m_button_2;<span class="comment">//卸载按钮</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    m_button_1.onClick.AddListener(Load);</span><br><span class="line">    m_button_2.onClick.AddListener(UnLoad);</span><br><span class="line">}</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加载资源</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"加载资源"</span>);</span><br><span class="line">    <span class="comment">//放张图片到Resources里的Tex文件夹下 方便测试加载</span></span><br><span class="line">    tex = Resources.Load&lt;Texture&gt;(<span class="string">"Tex/TestJPG"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 卸载资源</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnLoad</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"卸载资源"</span>);</span><br><span class="line">    Resources.UnloadAsset(tex);</span><br><span class="line">    tex = <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/Resources%E5%8D%B8%E8%BD%BD%E8%B5%84%E6%BA%90.gif" class="" title="Resources卸载资源" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Resources.UnloadAsset 卸载指定资源，但是不能卸载GameObject对象</li>
<li>Resources.UnloadUnusedAssets 卸载未使用资源，一般过场景时配合GC使用</li>
</ul>
<h1 id="场景异步加载"><a href="#场景异步加载" class="headerlink" title="场景异步加载"></a>场景异步加载</h1><p><code>创建异步加载</code></p>
<p><strong><font size="4">回顾场景同步切换:</font></strong></p>
<p><strong><font size="3">SceneManager.LoadScene 同步加载场景</font></strong></p>
<ul>
<li>引用命名空间 UnityEngine.SceneManagement;</li>
<li>场景同步切换</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.LoadScene(<span class="string">"测试场景名字"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">场景同步切换的缺点:</font></strong></p>
<ul>
<li>在切换场景时，Unity会删除当前场景上所有对象，并且去加载下一个场景的相关信息。</li>
<li>如果当前场景对象过多或者下一个场景对象过多，这个过程会非常耗时，会让玩家感受到卡顿。</li>
<li>所以异步切换就是来解决该问题的。</li>
</ul>
<p><strong><font size="4">场景异步切换:</font></strong></p>
<p><strong><font size="3">SceneManager.LoadSceneAsync 事件回调异步加载场景</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// SceneManager中的LoadSceneAsync方法通过事件回调函数异步加载</span></span><br><span class="line">    <span class="comment">// 在后台异步加载场景。</span></span><br><span class="line">    <span class="comment">// 这个方法有一个异步加载的协程返回值</span></span><br><span class="line">    <span class="comment">// AsyncOperation类 异步操作协同程序。里面有isDone、progress、completed等成员</span></span><br><span class="line">    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(<span class="string">"测试场景名字"</span>);</span><br><span class="line">    <span class="comment">// 当场景异步加载结束后就会自动调用该事件函数，我们如果希望在加载结束后做一些事情，那么就可以在该函数中写处理逻辑</span></span><br><span class="line">    asyncOperation.completed += (aO) =&gt;</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"加载结束"</span>);</span><br><span class="line">    };</span><br><span class="line">    asyncOperation.completed += AsynLoadOver;</span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// 直接用法这种方法异步加载场景的话，就算过场景脚本或脚本依附的对象被销毁，异步加载的回调也能执行</span></span><br><span class="line">    <span class="comment">// 因为异步加载的回调被存到事件中了</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载场景回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AsynLoadOver</span>(<span class="params">AsyncOperation ao</span>)</span></span><br><span class="line">{</span><br><span class="line">    print(<span class="string">"AsynLoadOver"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">协程异步加载:</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 通过协程异步加载</span></span><br><span class="line">    <span class="comment">// 需要注意的是，加载场景会把当前场景上没有特别处理的对象都删除了</span></span><br><span class="line">    <span class="comment">// 所以，协程中的部分逻辑可能是执行不了的</span></span><br><span class="line">    <span class="comment">// 因为过场景会把脚本或者脚本依附的对象都销毁了</span></span><br><span class="line">    <span class="comment">// 解决思路：让处理场景加载的脚本依附的对象过场景时不被移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让该脚本依附的对象过场景时不会被移除，这样脚本就不被移除，否则协程后面的逻辑会失效</span></span><br><span class="line">    DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    <span class="comment">// 协程后面的逻辑会失效是因为Unity的协程管理器的机制，只要依附的对象被删除或失活或者脚本被删除，协程就会失效，我们改不了这个机制</span></span><br><span class="line"></span><br><span class="line">    StartCoroutine(CoroutineAsynLoadScene(<span class="string">"测试场景名字"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载场景协程函数</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">CoroutineAsynLoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 异步加载场景</span></span><br><span class="line">    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程的好处是，在异步加载场景时，我可以在加载的同时做一些别的逻辑</span></span><br><span class="line">    print(<span class="string">"异步加载过程中打印的信息"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如，我们可以在异步加载过程中去更新进度条，一般有两种做法</span></span><br><span class="line">    <span class="comment">// 更新进度条第一种做法就是利用场景异步加载的进度去更新，但是不是特别准确，一般也不会直接用</span></span><br><span class="line">    <span class="keyword">while</span> (!asyncOperation.isDone)</span><br><span class="line">    {</span><br><span class="line">        print(asyncOperation.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开循环后就会认为场景加载结束</span></span><br><span class="line">    <span class="comment">// 可以把进度条顶满，然后隐藏进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unity内部的协程协调器发现是异步加载类型的返回对象，那么就会等待</span></span><br><span class="line">    <span class="comment">// 等待异步加载结束后才会继续执行迭代器函数中后面的步骤</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> asyncOperation;</span><br><span class="line">    print(<span class="string">"异步加载结束后打印的信息"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进度条第二种做法就是根据你游戏的规则自己定义进度条变化的条件</span></span><br><span class="line">    <span class="comment">// 比如：当场景加载结束更新20%进度</span></span><br><span class="line">    <span class="comment">// 接着去加载场景中的其他信息，比如动态加载怪物</span></span><br><span class="line">    <span class="comment">// 这时进度条再更新20%</span></span><br><span class="line">    <span class="comment">// 动态加载场景模型，这时就认为加载结束了，进度条顶满，隐藏进度条</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p><strong><font size="4">场景异步加载 和 资源异步加载 一样，有两种方式</font></strong></p>
<ul>
<li>通过事件回调函数</li>
<li>协程异步加载</li>
</ul>
<p><strong><font size="4">他们的优缺点表现和资源异步加载也是一样的</font></strong><br><strong><font size="3">事件回调函数</font></strong></p>
<ul>
<li>优点：写法简单，逻辑清晰</li>
<li>缺点：只能加载完场景做一些事情，不能再加载过程中处理逻辑</li>
</ul>
<p><strong><font size="3">协程异步加载</font></strong></p>
<ul>
<li>优点：可以在加载过程中处理逻辑，比如进度条更新等</li>
<li>缺点：写法较为麻烦，要通过协程</li>
</ul>
<h2 id="练习题-14"><a href="#练习题-14" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.请写一个简单的场景管理器，提供统一的方法给外部用于场景异步切换，外部可以传入委托用于当异步切换结束时执行某些逻辑</font></strong></p>
<details>
  <summary>查看答案</summary>

<ul>
<li>创建场景管理器单例类，添加异步加载场景函数并实现：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个场景管理类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneMgr</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 使用instance来实现单例模式，因为构造函数被声明为private，</span></span><br><span class="line">    <span class="comment">// 防止在类外部实例化本类的对象，保证了全局只有一个实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SceneMgr instance = <span class="keyword">new</span> SceneMgr();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 类似于getter方法，返回静态的SceneMgr实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SceneMgr Instance =&gt; instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数私有化，使得无法在类外部通过new直接创建该类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SceneMgr</span>()</span> { }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载场景的方法，需要传入目标场景的名称和一个UnityAction类型的委托参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name, UnityAction action</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//注意：资源异步加载的时候委托要有个泛型参数是因为要做的加载的是啥类型as一下</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异步加载目标场景，SceneManager.LoadSceneAsync返回一个AsyncOperation类型的值</span></span><br><span class="line">        AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在异步加载完成后执行的回调函数，将传入的委托类型的参数作为参数传入</span></span><br><span class="line">        asyncOperation.completed += (aO) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//注意：资源异步加载的时候用到aO这个参数是因为要把aO处理下拿到asset</span></span><br><span class="line">            <span class="comment">//(asyncOperation as ResourceRequest).asset</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过拉姆达表达式 包裹一层</span></span><br><span class="line">            <span class="comment">//在内部 直接调用外部传入的委托即可</span></span><br><span class="line">            action();  <span class="comment">// 直接执行传入的委托</span></span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>测试使用场景管理类异步加载：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">      SceneMgr.Instance.LoadScene(<span class="string">"测试场景名字"</span>, () =&gt; { print(<span class="string">"加载结束"</span>);});  <span class="comment">//这样加载一次代码量会少很多     </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</details>


<h1 id="LineRenderer画线渲染器组件"><a href="#LineRenderer画线渲染器组件" class="headerlink" title="LineRenderer画线渲染器组件"></a>LineRenderer画线渲染器组件</h1><p><code>画线功能LineRenderer</code></p>
<h2 id="LineRenderer组件参数-详解"><a href="#LineRenderer组件参数-详解" class="headerlink" title="LineRenderer组件参数 详解"></a>LineRenderer组件参数 详解</h2><p><strong><font size="4">LineRenderer画线渲染器组件是什么？</font></strong></p>
<ul>
<li><strong>LineRenderer</strong> 是Unity提供的一个用于画线的组件。</li>
<li>使用它我们可以在场景中绘制线段，一般可以用于：<br>绘制攻击范围<br>武器红外线<br>辅助功能<br>其它画线功能</li>
</ul>
<p><strong><font size="4">LineRenderer画线渲染器组件参数:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0.png" class="" title="LineRenderer" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="4">场景点编辑模式:</font></strong></p>
<p><strong><font size="3">编辑点和删除点:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0_%E5%9C%BA%E6%99%AF%E7%82%B9%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F.png" class="" title="场景点编辑模式" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="3">无编辑点操作:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0_%E6%97%A0%E7%BC%96%E8%BE%91%E6%93%8D%E4%BD%9C.png" class="" title="场景点编辑模式" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="3">Simplify Preview 简化预览:</font></strong></p>
<ul>
<li>开启会显示一个明显的线段</li>
</ul>
<p><strong><font size="3">Tolerance 宽容度</font></strong></p>
<ul>
<li>偏离值，越大，偏差越大</li>
<li>假如点分密集，宽容度越大，越只会画出粗略线段，一般设置为1就行</li>
</ul>
<p><strong><font size="3">编辑点操作:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0_%E7%BC%96%E8%BE%91%E7%82%B9%E6%93%8D%E4%BD%9C.png" class="" title="LineRenderer编辑点操作" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>Show Wireframe 显示线框</li>
<li>Subdivide Selected 细分选项:<br>鼠标左键画框选择两个或多个相邻点时，该按钮启用，点击后会在相邻点之间插入一个新点，可以移动改变点的位置</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E7%BC%96%E8%BE%91%E7%82%B9%E5%AE%9E%E6%B5%8B.gif" class="" title="LineRenderer组件_编辑操作点" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<p><strong><font size="3">添加点操作:</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0_%E6%B7%BB%E5%8A%A0%E7%82%B9%E6%93%8D%E4%BD%9C.png" class="" title="LineRenderer添加点操作" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">Input 输入模式</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0_%E6%B7%BB%E5%8A%A0%E7%82%B9%E6%93%8D%E4%BD%9C_2.png" class="" title="LineRenderer_Input参数-Mouse_Position" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">Mouse Position 鼠标位置：</font></strong></p>
<ul>
<li>点击会在摄像机处创建点，一般不用</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E6%B7%BB%E5%8A%A0%E7%82%B9_Input_Physics_Raycast.jpg" class="" title="LineRenderer_Input参数-Physics Raycast" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<p><strong><font size="3">Physics Raycast 基于物理射线：</font></strong></p>
<ul>
<li>鼠标点击到能触发射线的位置，添加点，比如平面，UI等</li>
</ul>
<p><strong><font size="3">LayerMask 选择哪些层可以检测射线</font></strong></p>
<p><strong><font size="3">Min VertexDistance 最小顶点距离</font></strong></p>
<ul>
<li>拖动鼠标创建点时，会在超出该距离时创建一个点</li>
</ul>
<p><strong><font size="3">Offset 偏移量</font></strong></p>
<ul>
<li>创建点的偏移值</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%AE%9E%E6%B5%8B.gif" class="" title="LineRenderer组件_添加点操作" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<p><strong><font size="4">Loop 循环</font></strong></p>
<ul>
<li>是否终点起始自动相连。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Loop.gif" class="" title="LineRenderer组件_Loop属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">Positions 位置</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Position%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Position参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>默认以世界坐标系为基准，设置线段的点并连接。</li>
<li>可以在 <strong>Use World Space</strong> 是否使用世界坐标系修改是否以世界坐标系为基准。</li>
<li>设置开不开启 <strong>Loop 循环</strong> 就能选择是否收尾线段点相连。</li>
</ul>
<p><strong><font size="4">Width 宽度</font></strong></p>
<ul>
<li>线段宽度曲线调整</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Width.gif" class="" title="LineRenderer组件_Width属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>可以在宽度表里右键添加key，添加秘钥，修改划线宽度曲线。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_WidthKey%E6%B7%BB%E5%8A%A0Key.gif" class="" title="LineRenderer组件_Width属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">Color 颜色</font></strong></p>
<ul>
<li>修改颜色变化，颜色也可以是渐变的，假如没有材质修改颜色不起作用。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Color.png" class="" title="LineRenderer组件_Color属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">Corner Vertices 角顶点</font></strong></p>
<ul>
<li>角顶点可以理解为把划线的角变成圆角。</li>
<li>此属性指示在一条线中绘制角时使用了多少额外的顶点。</li>
<li>增加此值，使线角看起来更圆。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_CornerVertices.gif" class="" title="LineRenderer组件_CornerVertices属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">End Cap Vertices 末端顶点</font></strong></p>
<ul>
<li>终端顶点也变成圆角。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_EndCapVertices.gif" class="" title="LineRenderer组件_EndCapVertices属性" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="4">Alignment 对齐方式</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Alignment%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Alignment参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">View：</font></strong></p>
<ul>
<li>视点线段对着摄像机。</li>
</ul>
<p><strong><font size="3">Transform Z：</font></strong></p>
<ul>
<li>线段面向其Z轴。</li>
</ul>
<p><strong><font size="4">Texture Mode 纹理模式</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_TextureMode%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Texture_Mode参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">Stretch：</font></strong></p>
<ul>
<li>拉伸，沿整条线映射纹理一次。</li>
</ul>
<p><strong><font size="3">Tile：</font></strong></p>
<ul>
<li>瓷砖平铺，不停的重复纹理。</li>
</ul>
<p><strong><font size="3">Distribute Per Segment：</font></strong></p>
<ul>
<li>分配执行。</li>
</ul>
<p><strong><font size="3">Repeat Per Segment：</font></strong></p>
<ul>
<li>重复显示。</li>
</ul>
<p><strong><font size="4">Shadow Bias 阴影偏移</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Shadow_Bias%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Shadow_Bias参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="4">Generate Lighting Data 生成光源数据</font></strong></p>
<p><strong><font size="4">Use World Space 是否使用世界坐标系</font></strong></p>
<ul>
<li>勾选了，不管怎么改都是相对于世界坐标的线段点。</li>
<li>不勾选，就会是当前依附的游戏对象的相对坐标点，移动游戏对象也会移动划线。</li>
</ul>
<p><strong><font size="4">Materials 划线使用的材质球</font></strong></p>
<ul>
<li>我们可以新建一个材质，使用默认shader，关联一张图片，拖拽到划线组件的材质球上。</li>
<li>有了材质之后可以修改Texture Mode 纹理模式查看效果。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E6%9D%90%E8%B4%A8%E7%90%83.png" class="" title="LineRenderer组件_材质球" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<blockquote>
<p>注意：假如一些材质需要光源，要开Generate Lighting Data 生成光源数据，不然可能变黑显示不出来。</p>
</blockquote>
<p><strong><font size="4">Lighting 光照影响</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Lighting%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Lighting参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


<p><strong><font size="3">Cast Shadows：</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Lighting%E5%8F%82%E6%95%B0_Cast_Shadows.jpg" class="" title="LineRenderer组件_Lighting参数-Cast_Shadows" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>投射阴影，是否开启阴影。</li>
</ul>
<p><strong><font size="3">Receive Shadows：</font></strong></p>
<ul>
<li>接收阴影。</li>
</ul>
<p><strong><font size="4">Probes 光照探针</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Probes%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Probes参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<p><strong><font size="3">Light Probes：光探测器模式</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Probes%E5%8F%82%E6%95%B0_Light_Probes.jpg" class="" title="LineRenderer组件_Probes参数-Light_Probes" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>Off：不使用光探针</li>
<li>Blend Probes：使用内插光探针</li>
<li>Use Proxy Volume：使用三维网格内插光探针</li>
<li>Custom Provided：自定义从材质决定</li>
</ul>
<p><strong><font size="3">Reflection Probes：反射探测器模式</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Probes%E5%8F%82%E6%95%B0_Reflection_Probes.jpg" class="" title="LineRenderer组件_Probes参数-Reflection_Probes" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>Off：不使用反射探针</li>
<li>Blend Probes：启用混合反射探针</li>
<li>Blend Probes And Skybox：启用混合反射探针并且和天空和混合</li>
<li>Simple：启用普通探针，重叠式不混合</li>
</ul>
<p><strong><font size="4">Additional Settings 附加设置</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Additional_Settings%E5%8F%82%E6%95%B0.jpg" class="" title="LineRenderer组件_Additional Settings参数" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<p><strong><font size="3">Motion Vectors：运动矢量</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_Additional_Settings%E5%8F%82%E6%95%B0_Motion_Vectors.jpg" class="" title="LineRenderer组件_Additional Settings参数-Motion Vectors" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>

<ul>
<li>Camera Motion Only：使用相机运动来跟踪运动</li>
<li>Per Object Motion：特定对象来跟踪运动</li>
<li>Force No Motion：不跟踪</li>
</ul>
<p><strong><font size="3">Dynamic Occludee：</font></strong></p>
<ul>
<li>动态遮挡剔除</li>
</ul>
<p><strong><font size="3">Sorting Layer：</font></strong></p>
<ul>
<li>排序图层</li>
</ul>
<p><strong><font size="3">Order in Layer：</font></strong></p>
<ul>
<li>此线段在排序图层中的顺序</li>
</ul>
<h2 id="Linerenderer组件代码-详解"><a href="#Linerenderer组件代码-详解" class="headerlink" title="Linerenderer组件代码 详解"></a>Linerenderer组件代码 详解</h2><p><strong><font size="4">LineRenderer画线渲染器代码控制</font></strong><br><strong><font size="3">动态添加一个线段</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    GameObject line = <span class="keyword">new</span> GameObject();</span><br><span class="line">    line.name = <span class="string">"Line"</span>;</span><br><span class="line">    LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">loop变量 首尾相连</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//将线的起点和终点位置连接在一起，以形成连续循环。</span></span><br><span class="line">    lineRenderer.loop = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">startWidth和endWidth变量 开始结束宽</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置线起点处的宽度。</span></span><br><span class="line">    <span class="comment">//设置线终点处的宽度。</span></span><br><span class="line">    lineRenderer.startWidth = <span class="number">0.02f</span>;</span><br><span class="line">    lineRenderer.endWidth = <span class="number">0.02f</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">startColor和endColor变量 开始结束颜色</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置线起点处的颜色。</span></span><br><span class="line">    <span class="comment">//设置线终点处的颜色。</span></span><br><span class="line">    lineRenderer.startColor = Color.white;</span><br><span class="line">    lineRenderer.endColor = Color.red;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">material变量 设置材质</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//返回指定给渲染器的第一个实例化 Material。</span></span><br><span class="line">    material = Resources.Load&lt;Material&gt;(<span class="string">"测试材质"</span>);<span class="comment">//创建材质球到Resources里</span></span><br><span class="line">    lineRenderer.material = material;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">positionCount变量 设置点个数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置 /获取顶点数。</span></span><br><span class="line">    <span class="comment">//一定注意 设置点 要 先设置点的个数</span></span><br><span class="line">    lineRenderer.positionCount = <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">SetPositions方法 设置点位置</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置线中所有顶点的位置。</span></span><br><span class="line">    <span class="comment">//接着就设置 对应每个点的位置</span></span><br><span class="line">    lineRenderer.SetPositions(<span class="keyword">new</span> Vector3[] { <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>), <span class="keyword">new</span> Vector3(<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>)});</span><br><span class="line">    <span class="comment">//注意：假如positionCount设置的点的数量比SetPositions传入点具体值的数量多，多出的点默认就在(0,0,0)位置</span></span><br><span class="line">    lineRenderer.SetPosition(<span class="number">3</span>, <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//设置好最后一个点</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">useWorldSpace变量 是否使用世界坐标系</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//如果启用，则在世界空间中定义线。</span></span><br><span class="line">    <span class="comment">//决定了 是否随对象移动而移动</span></span><br><span class="line">    lineRenderer.useWorldSpace = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">generateLightingData变量 判断是否让线段受光影响</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//配置线以生成法线和切线。借助此数据，场景光照可以通过法线贴图和 Unity 标准着色器或是您自己的定制着色器来影响线。</span></span><br><span class="line">    lineRenderer.generateLightingData = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="练习题-15"><a href="#练习题-15" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.请写一个方法，传入一个中心点，传入一个半径，用 LineRenderer 画一个圆出来</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">添加画圆函数，需要传入圆心位置(centerPos)，半径(r)，点的数量(pointNum)</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画圆函数，需要传入圆心位置(centerPos)，半径(r)，点的数量(pointNum)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawLineRenderer</span>(<span class="params">Vector3 centerPos, <span class="built_in">float</span> r, <span class="built_in">int</span> pointNum</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 动态创建一个游戏对象，并设置其名称为 "R"</span></span><br><span class="line">    GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">    obj.name = <span class="string">"R"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给该游戏对象添加 LineRenderer 组件</span></span><br><span class="line">    LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线段是否是闭合状态来避免首尾连接处有断裂</span></span><br><span class="line">    line.loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点数来确定每条线段的终点可以组成一个圆</span></span><br><span class="line">    line.positionCount = pointNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据点的数量得到每个点之间的度数角度</span></span><br><span class="line">    <span class="built_in">float</span> angle = <span class="number">360f</span> / pointNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的顶点，计算每个顶点相对于圆心在平面上固定的偏移指向，并赋值形成圆环状</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 知识点</span></span><br><span class="line">        <span class="comment">// 1. 点加向量相当于平移点</span></span><br><span class="line">        <span class="comment">// 2. 四元数 * 向量相当于在旋转向量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过四元数进行旋转后，再进行位移操作</span></span><br><span class="line">        Vector3 pos = Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r + centerPos;</span><br><span class="line">        <span class="comment">// Vector3.forward * r 代表方向向量乘半径，就是当前向量</span></span><br><span class="line">        <span class="comment">// Quaternion.AngleAxis(angle * i, Vector3.up) 代表绕着 y 轴转，当前角转的度数是当前索引乘根据点的数量得到每个点之间的度数角度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前索引的点</span></span><br><span class="line">        line.SetPosition(i, pos);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">调用画圆函数</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 调用画圆函数</span></span><br><span class="line">    DrawLineRenderer(Vector3.zero, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E7%BB%83%E4%B9%A01.png" class="" title="使用LineRenderer画圆" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


</details>
 

<p><strong><font size="4">2.请实现，在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹</font></strong></p>
<details>
  <summary>查看答案</summary>

<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 练习题二用来装 LineRenderer 的临时变量</span></span><br><span class="line"><span class="keyword">private</span> LineRenderer line2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 练习题二</span></span><br><span class="line">    <span class="comment">// 在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/假如没有添加鼠标左键被按下时的逻辑，那么每次只能接着上次画，会和上次画的末尾连接起来</span></span><br><span class="line">    <span class="comment">//line2 = this.gameObject.AddComponent&lt;LineRenderer&gt;();</span></span><br><span class="line">    <span class="comment">//line2.loop = false;</span></span><br><span class="line">    <span class="comment">//line2.startWidth = 0.5f;</span></span><br><span class="line">    <span class="comment">//line2.endWidth = 0.5f;</span></span><br><span class="line">    <span class="comment">//line2.positionCount = 0;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类成员变量 nowPos，记录当前鼠标指针所在的位置</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Update 函数中，检测鼠标点击事件，实现从当前鼠标指针处开始划线的功能。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 鼠标左键被按下时</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 鼠标左键被按下时，创建新的游戏对象，并且新增为其 LineRenderer 组件</span></span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">        line2 = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线段状态为非闭合状态，设置开始和结束的宽度为 0.5</span></span><br><span class="line">        line2.loop = <span class="literal">false</span>;</span><br><span class="line">        line2.startWidth = <span class="number">0.5f</span>;</span><br><span class="line">        line2.endWidth = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置顶点数目为 0 表示该线段暂时为空</span></span><br><span class="line">        line2.positionCount = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标左键持续按压时</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 鼠标左键持续按压时，不断新增线段中增加顶点，记录每个顶点的世界坐标，直到松开鼠标键停止绘制。</span></span><br><span class="line">        line2.positionCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何得到鼠标转世界坐标的对应点 </span></span><br><span class="line">        <span class="comment">// 知识点</span></span><br><span class="line">        <span class="comment">// 1. 如何得到鼠标位置</span></span><br><span class="line">        <span class="comment">// Input.mousePosition</span></span><br><span class="line">        <span class="comment">// 2. 怎么把鼠标转世界坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Camera.main.ScreenToWorldPoint() 方法来将当前鼠标所在的屏幕像素坐标转换到和场景中对象相对应的世界坐标上。</span></span><br><span class="line">        nowPos = Input.mousePosition;</span><br><span class="line">        <span class="comment">// 这个 z 是设置和摄像机的距离的，这样画出来的线一直和摄像机的距离是 10</span></span><br><span class="line">        nowPos.z = <span class="number">10</span>;  <span class="comment">// 将 Z 轴坐标设置为一个固定值，使得线段可以显示在屏幕上方</span></span><br><span class="line">        line2.SetPosition(line2.positionCount - <span class="number">1</span>, Camera.main.ScreenToWorldPoint(nowPos));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">运行效果</font></strong></p>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/LineRenderer%E7%BB%84%E4%BB%B6_%E7%BB%83%E4%B9%A02.gif" class="" title="LineRenderer 画出鼠标移动的轨迹" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>


</details>
 
<h1 id="范围检测"><a href="#范围检测" class="headerlink" title="范围检测"></a>范围检测</h1><p><code>核心系统-物理系统-范围检测</code></p>
<p><strong><font size="4">知识回顾 物理系统之碰撞检测</font></strong><br><strong><font size="3">碰撞产生的必要条件</font></strong></p>
<ul>
<li>至少一个物体有刚体</li>
<li>两个物体都必须有碰撞器</li>
</ul>
<p><strong><font size="3">碰撞和触发</font></strong></p>
<ul>
<li>碰撞会产生实际的物理效果</li>
<li>触发看起来不会产生碰撞，但是可以通过函数监听触发</li>
<li>碰撞检测主要用于实体物体之间产生物理效果时使用</li>
</ul>
<p><strong><font size="4">什么是范围检测?</font></strong></p>
<ul>
<li>游戏中瞬时的攻击范围判断一般会使用范围检测</li>
<li>举例：<br>· 玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害<br>· 玩家攻击，在前方1米圆形范围内对象都受到伤害<br>· 类似这种并没有实体物体，只想要检测在指定某一范围是否让敌方受到伤害时，便可以使用范围判断</li>
<li>在指定位置进行范围判断，我们可以得到处于指定范围内的对象</li>
<li>目的是对对象进行处理，比如受伤、减血等等</li>
</ul>
<p><strong><font size="4">层级</font></strong><br><strong><font size="3">LayerMask中的NameToLayer方法 传入层级名字返回层级索引</font></strong></p>
<ul>
<li>给定层名称，返回在 Tags and Layers manager 中由 Builtin 或 User Layer 定义的层索引。</li>
</ul>
<img src="/Test.github.io/2025/03/14/Unity%E5%9F%BA%E7%A1%80/%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B_%E5%B1%82%E7%BA%A7.jpg" class="" title="层级" loading="lazy" onerror='this.onerror=null;this.src="/Test.github.io/img/404.jpg"'>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    print(LayerMask.NameToLayer(<span class="string">"UI"</span>)); <span class="comment">// 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">层级重要知识点补充 通过编号左移构建二进制数</font></strong></p>
<ul>
<li>通过名字得到层级编号 LayerMask.NameToLayer</li>
<li>我们需要通过编号左移构建二进制数</li>
<li>这样每一个编号的层级都是对应位为1的2进制数</li>
<li>我们通过位运算可以选择想要检测的层级</li>
<li>好处是一个int就可以表示所有想要检测的层级信息</li>
<li>层级编号是 0~31，刚好32位，是一个int数的比特位数</li>
<li>每一个编号代表的都是二进制的一位<br>· 第0层—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1<br>· 第1层—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2<br>· 第2层—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4<br>· 第3层—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8<br>· 第4层—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16<br>· 第5层—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32</li>
</ul>
<p><strong><font size="3">层级重要知识点通俗理解</font></strong></p>
<p><strong><font size="3">Unity是用二进制来判断层级的</font></strong></p>
<ul>
<li>比如：<br>· LayerMask.NameToLayer(“Default”) 是第0层，就用二进制0000 0001来代表这一层，1左移了0位<br>· LayerMask.NameToLayer(“UI”) 是第5层，就用二进制0010 0000来代表这一层，1左移了5位</li>
<li>假如既想检测Default层又想检测UI层，就把这两个层级的二进制进行或运算<br>· 1 &lt;&lt; LayerMask.NameToLayer(“UI”) | 1 &lt;&lt; LayerMask.NameToLayer(“Default”)</li>
<li>或运算后的二进制是 0010 0001</li>
<li>当触发层级检测时，就拿出这个算好的0010 0001和对应的层级的二进制进行与操作<br>· 比如和第1层进行与操作<br>——&gt; 0010 0001<br>——&gt; 0000 0010<br>——&gt; 0000 0000<br>——&gt; 得到的是0，就不进行这一层级的判断了<br>· 假如和第5层进行与操作<br>——&gt; 0010 0001<br>——&gt; 0010 0000<br>——&gt; 0010 0000<br>——&gt; 得到的数不为0，就进行这一层级判断</li>
</ul>
<p><strong><font size="4">范围检测必备条件</font></strong></p>
<ul>
<li>想要被范围检测到的对象必须具备碰撞器</li>
</ul>
<p><strong><font size="4">范围检测注意点</font></strong></p>
<ul>
<li>范围检测相关API只有当执行该句代码时进行一次范围检测，它是瞬时的</li>
<li>范围检测相关API并不会真正产生一个碰撞器，只是碰撞判断计算而已</li>
</ul>
<p><strong><font size="4">范围检测API</font></strong><br><strong><font size="3">Physics.OverlapBox方法 盒状范围检测</font></strong></p>
<ul>
<li>查找与给定盒体接触或位于盒体内部的所有碰撞体。</li>
<li>返回值：在该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapBox静态方法 盒状范围检测</span></span><br><span class="line">    <span class="comment">//查找与给定盒体接触或位于盒体内部的所有碰撞体。</span></span><br><span class="line">    <span class="comment">//他不是一直都会检测的 可以通俗的理解为在执行代码的瞬间在场景创建一个盒型碰撞器检测碰撞的对象 但只是用于计算碰撞情况 不是真的创建出来</span></span><br><span class="line">    <span class="comment">//参数一：立方体中心点</span></span><br><span class="line">    <span class="comment">//参数二：立方体三边大小 构成立方体的长宽高的一半</span></span><br><span class="line">    <span class="comment">//参数三：立方体角度 传入四元数</span></span><br><span class="line">    <span class="comment">//参数四：检测指定层级（不填检测所有层） 用NameToLayer传入对应层级名字 并且要用1 &lt;&lt;左移 可以或运算</span></span><br><span class="line">    <span class="comment">//参数五：</span></span><br><span class="line">    <span class="comment">//是否忽略触发器 UseGlobal-使用全局设置 不填默认使用UseGlobal 全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置</span></span><br><span class="line">    <span class="comment">//Collide-检测触发器 Ignore-忽略触发器 手动选择单独设置</span></span><br><span class="line">    <span class="comment">//返回值：在该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）</span></span><br><span class="line">    Collider[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up),</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"UI"</span>) |</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Default"</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印在该范围内的碰撞器的所有信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">    {</span><br><span class="line">        print(colliders[i].gameObject.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.OverlapBoxNonAlloc方法 盒状范围检测</font></strong></p>
<ul>
<li>查找与给定盒体接触或位于盒体内部的所有碰撞体，并将它们存储到缓冲区中。</li>
<li>返回值：碰撞到的碰撞器数量</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapBoxNonAlloc静态方法 盒状范围检测 并且要传入一个数组 数组会装载碰撞到的碰撞器 返回碰撞器个数</span></span><br><span class="line">    <span class="comment">//查找与给定盒体接触或位于盒体内部的所有碰撞体，并将它们存储到缓冲区中。</span></span><br><span class="line">    <span class="comment">//参数：和OverlapBox相比，要多传入一个数组，会存储碰撞到的碰撞器，其他参数都差不多</span></span><br><span class="line">    <span class="comment">//返回值：碰撞到的碰撞器数量</span></span><br><span class="line">    <span class="comment">//Physics.OverlapBoxNonAlloc()</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 处理碰撞器</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Physics.OverlapSphere方法 球形范围检测</font></strong></p>
<ul>
<li>计算并存储接触球体或位于球体内部的碰撞体。</li>
<li>返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapSphere静态方法 球形范围检测</span></span><br><span class="line">    <span class="comment">//计算并存储接触球体或位于球体内部的碰撞体。</span></span><br><span class="line">    <span class="comment">//参数一：中心点</span></span><br><span class="line">    <span class="comment">//参数二：球半径</span></span><br><span class="line">    <span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span><br><span class="line">    <span class="comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span></span><br><span class="line">    <span class="comment">//返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</span></span><br><span class="line">    colliders = Physics.OverlapSphere(Vector3.zero, <span class="number">5</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Default"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.OverlapSphereNonAlloc方法 球形范围检测</font></strong></p>
<ul>
<li>计算与球体接触或位于球体内部的碰撞体，并将它们存储到提供的缓冲区中。</li>
<li>返回值：碰撞到的碰撞器数量</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapSphereNonAlloc静态方法 球形范围检测 并且要传入一个数组 数组会装载碰撞到的碰撞器 返回碰撞器个数</span></span><br><span class="line">    <span class="comment">//计算与球体接触或位于球体内部的碰撞体，并将它们存储到提供的缓冲区中。</span></span><br><span class="line">    <span class="comment">//参数：和OverlapSphereNonAlloc相比，要多传入一个数组，会存储碰撞到的碰撞器，其他参数都差不多</span></span><br><span class="line">    <span class="comment">//返回值：碰撞到的碰撞器数量</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.OverlapSphereNonAlloc(Vector3.zero, <span class="number">5</span>, colliders) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.OverlapCapsule方法 胶囊范围检测</font></strong></p>
<ul>
<li>在物理世界中检查给定胶囊体，并返回所有重叠的碰撞体。</li>
<li>返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapCapsule静态方法 胶囊范围检测</span></span><br><span class="line">    <span class="comment">//在物理世界中检查给定胶囊体，并返回所有重叠的碰撞体。</span></span><br><span class="line">    <span class="comment">//参数一：半圆一中心点</span></span><br><span class="line">    <span class="comment">//参数二：半圆二中心点</span></span><br><span class="line">    <span class="comment">//前两个参数决定胶囊中间的圆柱体情况</span></span><br><span class="line">    <span class="comment">//参数三：上下两个半球体半径</span></span><br><span class="line">    <span class="comment">//参数四：检测指定层级（不填检测所有层）</span></span><br><span class="line">    <span class="comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span></span><br><span class="line">    <span class="comment">//返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</span></span><br><span class="line">    colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"UI"</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Physics.OverlapCapsuleNonAlloc方法 胶囊范围检测</font></strong></p>
<ul>
<li>在物理世界中检查给定胶囊体，并在用户提供的缓冲区中返回所有重叠的碰撞体。</li>
<li>返回值：碰撞到的碰撞器数量</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.OverlapCapsuleNonAlloc静态方法 胶囊范围检测 并且要传入一个数组 数组会装载碰撞到的碰撞器 返回碰撞器个数</span></span><br><span class="line">    <span class="comment">//在物理世界中检查给定胶囊体，并在用户提供的缓冲区中返回所有重叠的碰撞体。</span></span><br><span class="line">    <span class="comment">//参数：和OverlapCapsule相比，要多传入一个数组，会存储碰撞到的碰撞器，其他参数都差不多</span></span><br><span class="line">    <span class="comment">//返回值：碰撞到的碰撞器数量</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="number">1</span>, colliders) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><ul>
<li>范围检测主要用于瞬时的碰撞范围检测</li>
<li>主要掌握Physics类中的静态方法，球形、盒装、胶囊三种API的使用即可</li>
</ul>
<h2 id="练习题-16"><a href="#练习题-16" class="headerlink" title="练习题"></a>练习题</h2><p><strong><font size="4">1.世界坐标原点有一个立方体，键盘WASD键可以控制其前后移动和旋转,请结合所学知识实现,按J键在立方体面朝向前方1米处进行立方体范围检测,按K键在立方体前面5米范围内进行胶囊范围检测,按L键以立方体脚下为原点，半径10米内进行球形范围检测</font></strong></p>
<details>
  <summary>查看答案</summary>

<p><strong><font size="3">定义了两个公开变量，分别表示移动速度和旋转速度。</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本要挂载到立方体上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 定义了两个公开变量，分别表示移动速度和旋转速度。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">在 Update 函数中检测角色的输入操作，并且通过 Unity3D 提供的 Physics 类进行场景物理模拟碰撞检测的应用和执行，根据按下 J, K 和 L 键不同会得到不同类型的碰撞检测结果。</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span>:<span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 在 Update 函数中检测角色的输入操作，并且通过 Unity3D 提供的 Physics 类进行场景物理模拟碰撞检测的应用和执行，根据按下 J, K 和 L 键不同会得到不同类型的碰撞检测结果。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 位移：使用 this.transform.Translate() 将角色对应的游戏对象在沿着 Z 轴正方向移动速度（moveSpeed）单位*(Input.GetAxis("Vertical")) </span></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis(<span class="string">"Vertical"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转：使用 this.transform.Rotate() 将角色对应的游戏对象 沿着 Y 轴正方向 绕转速(roundSpeed)制*Time.deltaTime 角度*(Input.GetAxis("Horizontal"))</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Rotate(Vector3.up, Input.GetAxis(<span class="string">"Horizontal"</span>) * roundSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下J键进行碰撞检测：在当前位置追加一个长宽高半径为0.5f的盒子，在指定图层标识（Monster）中查找已有物体</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.J))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//因为是长宽高的一半 使用用单位向量乘0.5 传入 Vector3.one * 0.5f 这样才算一个长宽高都是1的立方体</span></span><br><span class="line">        <span class="comment">//创建出来的立方体要保持和当前立方体相同的旋转，否则不是刚好在前面</span></span><br><span class="line">        Collider[] colliders = Physics.OverlapBox(<span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward, Vector3.one * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"盒子 物体受伤"</span> + colliders[i].gameObject.name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下K键进行碰撞检测：在当前位置追加一个纵向长度为5,由一顶端圆柱和两个相互背离异形盘组成的胶囊体，并且在指定图层标识（Monster）中查找已有物体。</span></span><br><span class="line">    <span class="comment">//可以理解为往前面吐火 或者刺出来长枪</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.K))</span><br><span class="line">    {</span><br><span class="line">        Collider[] colliders = Physics.OverlapCapsule(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward * <span class="number">5</span>, <span class="number">0.5f</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"胶囊 物体受伤"</span> + colliders[i].gameObject.name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下L键进行碰撞检测：以当前位置为球心，在半径为10米的范围内，检测并返回指定物理图层（Monster）下所有的碰撞体 collider</span></span><br><span class="line">    <span class="comment">//比如有些时候范围内加buff或者震开敌人</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.L))</span><br><span class="line">    {</span><br><span class="line">        Collider[] colliders = Physics.OverlapSphere(<span class="keyword">this</span>.transform.position, <span class="number">10</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            print(<span class="string">"球 物体受伤"</span> + colliders[i].gameObject.name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>
  
<h1 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h1><p><code>核心系统-物理系统-射线检测</code></p>
<p><strong><font size="4">什么是射线检测？</font></strong></p>
<ul>
<li>物理系统中</li>
<li>目前我们学习的物体相交判断</li>
<li>碰撞检测 - 必备条件 - 1刚体 2碰撞器</li>
<li>范围检测 - 必备条件 - 碰撞器</li>
</ul>
<p><strong><font size="3">如果想要做这样的碰撞检测呢？</font></strong></p>
<ul>
<li>鼠标选择场景上一物体</li>
<li>FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</li>
<li>等等 需要判断一条线和物体的碰撞情况</li>
</ul>
<p><strong><font size="3">射线检测 就是来解决这些问题的</font></strong></p>
<ul>
<li>它可以在指定点发射一个指定方向的射线</li>
<li>判断该射线与哪些碰撞器相交，得到对应对象</li>
</ul>
<p><strong><font size="4">射线对象</font></strong></p>
<p><strong><font size="3">Ray射线类</font></strong></p>
<ul>
<li>假设有一条起点为坐标(1,0,0) 方向为世界坐标Z轴正方向的射线</li>
</ul>
<p><strong><font size="3">Ray的无参构造函数</font></strong></p>
<ul>
<li>一般不会用无参构造初始化射线，因为后面还需要重写设置，很麻烦</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Ray ray1 = <span class="keyword">new</span> Ray();</span><br><span class="line">    ray1.origin = Vector3.right;</span><br><span class="line">    ray1.direction = Vector3.forward;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Ray的有参构造函数</font></strong></p>
<ul>
<li>参数一：起点</li>
<li>参数二：方向</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Ray ray2 = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Ray.origin变量 射线的起点</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Ray中的origin变量 起点</span></span><br><span class="line">    <span class="comment">//射线的原点。</span></span><br><span class="line">    print(ray2.origin);<span class="comment">//起点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">Ray.direction变量 射线的方向</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Ray中的direction变量 方向</span></span><br><span class="line">    <span class="comment">//射线的方向。</span></span><br><span class="line">    print(ray2.direction);<span class="comment">//方向</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="4">Camera.ScreenPointToRay方法 摄像机发射出的射线</font></strong></p>
<ul>
<li>返回从摄像机通过屏幕点的光线</li>
<li>得到一条从屏幕位置作为起点，摄像机视口方向为方向的射线</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    Ray ray3 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="3">注意：射线要结合物理系统</font></strong></p>
<ul>
<li>单独的射线对于我们来说没有实际的意义</li>
<li>我们需要用它结合物理系统进行射线碰撞判断</li>
</ul>
<p><strong><font size="4">碰撞检测函数</font></strong><br>Physics类中提供了很多进行射线检测的静态函数</p>
<ul>
<li>他们有很多种重载类型，我们只需要掌握核心的几个函数，其它函数自然就明白什么意思了</li>
<li>射线检测也是瞬时的，执行代码时进行一次射线检测</li>
</ul>
<p>准备一条射线</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray4 = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.Raycast方法 发射射线</font></strong></p>
<ul>
<li>向场景中的所有碰撞体投射一条射线，该射线起点为 / origin /，朝向 / direction /，长度为 / maxDistance /。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.Raycast方法重载 最原始的射线检测 如果碰撞到对象 返回true</span></span><br><span class="line">    <span class="comment">//参数一：射线</span></span><br><span class="line">    <span class="comment">//参数二: 检测的最大距离 超出这个距离不检测</span></span><br><span class="line">    <span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span><br><span class="line">    <span class="comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 不填默认使用UseGlobal 全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置</span></span><br><span class="line">    <span class="comment">//返回值：bool 当碰撞到对象时 返回 true 没有 返回false</span></span><br><span class="line">    <span class="comment">//Physics.Raycast方法不传入RaycastHit对象的话不能得到碰到的对象是谁</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(ray4, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"碰撞到了对象"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span><br><span class="line">    <span class="comment">//就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向</span></span><br><span class="line">    <span class="comment">//Physics.Raycast方法不传入RaycastHit对象的话不能得到碰到的对象是谁</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"碰撞到了对象2"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Physics.Raycast方法重载 获取相交的单个物体信息 如果碰撞到对象 返回true</span></span><br><span class="line">    <span class="comment">//物体信息类 RaycastHit</span></span><br><span class="line">    RaycastHit raycastHitInfo;</span><br><span class="line">    <span class="comment">//参数一：射线</span></span><br><span class="line">    <span class="comment">//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中</span></span><br><span class="line">    <span class="comment">//参数三：距离</span></span><br><span class="line">    <span class="comment">//参数四：检测指定层级（不填检测所有层）</span></span><br><span class="line">    <span class="comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 不填默认使用UseGlobal 全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置</span></span><br><span class="line">    <span class="comment">//Physics.Raycast方法传入RaycastHit对象的话可以得到碰到的对象是谁</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(ray4, <span class="keyword">out</span> raycastHitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"碰撞到了物体 得到了信息"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit.collider变量 碰撞器信息</span></span><br><span class="line">        <span class="comment">//命中的 Collider。</span></span><br><span class="line">        print(<span class="string">"碰撞到物体的名字"</span> + raycastHitInfo.collider.gameObject.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit.point变量 碰撞到的点</span></span><br><span class="line">        <span class="comment">//世界空间中射线命中碰撞体的撞击点。</span></span><br><span class="line">        <span class="comment">//可以用于射击游戏创建特效 比如被子弹打中飙血，墙壁被打贴图</span></span><br><span class="line">        print(raycastHitInfo.point);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit.normal变量 法线信息向量</span></span><br><span class="line">        <span class="comment">//射线命中的表面的法线。</span></span><br><span class="line">        <span class="comment">//可以用于射击游戏特效计算相关 比如被子弹打中后反射的角度 贴图的角度</span></span><br><span class="line">        print(raycastHitInfo.normal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit.transform变量 得到碰撞到对象的位置</span></span><br><span class="line">        <span class="comment">//命中的刚体或碰撞体的 Transform。</span></span><br><span class="line">        print(raycastHitInfo.transform.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit.distance变量 得到碰撞到对象 离自己的距离</span></span><br><span class="line">        <span class="comment">//从射线原点到撞击点的距离。</span></span><br><span class="line">        <span class="comment">//可能通过距离 模拟子弹受重力影响下落的高度</span></span><br><span class="line">        print(raycastHitInfo.distance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RaycastHit 该类 对于我们的意义</span></span><br><span class="line">        <span class="comment">//它不仅可以得到我们碰撞到的对象信息</span></span><br><span class="line">        <span class="comment">//还可以得到一些 碰撞的点 距离 法线等等的信息</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span><br><span class="line">    <span class="comment">//就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向</span></span><br><span class="line">    <span class="comment">//Physics.Raycast方法传入RaycastHit对象的话可以得到碰到的对象是谁</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="keyword">out</span> raycastHitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.RaycastAll方法 发射射线 获取相交的多个物体</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.RaycastAll方法 发射射线 获取相交的多个物体 可以得到碰撞到的多个对象 如果没有 就是容量为0的数组</span></span><br><span class="line">    <span class="comment">//向场景中投射射线并返回所有命中对象。注意，这些结果的顺序未定义。</span></span><br><span class="line">    <span class="comment">//参数一：射线</span></span><br><span class="line">    <span class="comment">//参数二：距离</span></span><br><span class="line">    <span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span><br><span class="line">    <span class="comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 不填默认使用UseGlobal 全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置</span></span><br><span class="line">    <span class="comment">//Physics.RaycastAll方法传入RaycastHit数组对象可以得到多个碰到的对象</span></span><br><span class="line">    RaycastHit[] raycastHitInfos = Physics.RaycastAll(ray4, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; raycastHitInfos.Length; i++)</span><br><span class="line">    {</span><br><span class="line">        print(<span class="string">"碰到的所有物体 名字分别是"</span> + raycastHitInfos[i].collider.gameObject.name);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span><br><span class="line">    <span class="comment">//之前的参数一射线 通过两个点传入</span></span><br><span class="line">    raycastHitInfos = Physics.RaycastAll(Vector3.zero, Vector3.forward, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong><font size="3">Physics.RaycastNonAlloc方法 发射射线获取相交的多个物体</font></strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Physics.RaycastNonAlloc方法 发射射线 要传入RaycastHit数组 通过out得到数据赋值到数组中 返回的碰撞的数量 </span></span><br><span class="line">    <span class="comment">//向场景中投射射线，并将命中对象存储到缓冲区中。</span></span><br><span class="line">    <span class="keyword">if</span> (Physics.RaycastNonAlloc(ray4, raycastHitInfos, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal) &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><font size="4">射线检测使用时注意的问题</font></strong></p>
<ul>
<li>距离、层级两个参数都是int类型</li>
<li>当我们传入参数时，一定要明确传入的参数代表的是距离还是层级</li>
<li>举例：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray4, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>)))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 错误的代码示例</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这样写是错误的，因为第二个参数代表的是距离，不是层级</li>
</ul>
<h1 id="练习题-17"><a href="#练习题-17" class="headerlink" title="练习题"></a>练习题</h1><h2 id="TOOD"><a href="#TOOD" class="headerlink" title="TOOD"></a>TOOD</h2><h1 id="Unity基础知识总结"><a href="#Unity基础知识总结" class="headerlink" title="Unity基础知识总结"></a>Unity基础知识总结</h1><!-- <blockquote class="pullquote mindmap mindmap-md"><ul>
<li>基础知识<ul>
<li>3D数学<ul>
<li>数学计算公共类Mathf</li>
<li>三角函数</li>
<li>Unity中的坐标系</li>
<li>Vector3向量<ul>
<li>向量模长和单位向量</li>
<li>向量加减乘除</li>
<li>向量点乘</li>
<li>向量叉乘 </li>
<li>差值运算</li>
</ul>
</li>
<li>Quaternion四元数<ul>
<li>为何使用四元数</li>
<li>四元数是什么</li>
<li>四元数常用方法</li>
<li>四元数计算</li>
</ul>
</li>
</ul>
</li>
<li>Monno中的重要内容<ul>
<li>延迟(延时)函数</li>
<li>协同程序</li>
<li>协同程序原理</li>
</ul>
</li>
<li>Resources资源动态加载<ul>
<li>Unity中的特殊文件夹</li>
<li>Resources同步加载</li>
<li>Resources异步加载</li>
<li>Resources卸载资源</li>
</ul>
</li>
<li>场景异步切换</li>
<li>画线功能LineRenderer</li>
<li>核心系统<ul>
<li>物理系统之范围检测</li>
<li>物理系统之射线检测</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>–&gt;</p>
--></body></html><link rel="stylesheet" href="/Test.github.io/css/folder.css" type="text/css"><script src="/Test.github.io/js/folder.js" type="text/javascript" async></script><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"><link rel="stylesheet" href="/Test.github.io/css/spoiler.css" type="text/css"><script src="/Test.github.io/js/spoiler.js" type="text/javascript" async></script>
</article>
    
    

</div>
<div id="post-next-prev" class="row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            其他文章
            <span data-number="02"></span>
        </h5>
    </div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/Test.github.io/2025/03/13/Unity%E5%85%A5%E9%97%A8/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/Test.github.io/img/%E5%9B%BE%E7%89%872.png">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" #.">
                    未分类
                </a>
            </div>
            <h5>
                <a href="/Test.github.io/2025/03/13/Unity%E5%85%A5%E9%97%A8/" class="trm-anima-link">
                    Unity入门
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/03/13</li>
                <li>09:36</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-scroll-animation">

    

    

    
        <div class="trm-footer-item">
            <span>
                由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0
            </span>
            <span class="footer-separator" data-separator=" | "></span>
            <span> 
                主题 - 
                <a rel="noopener" href='https://github.com/MaLuns/hexo-theme-async' target='_blank'>Async</a>
                v2.1.0-beta.2
            </span>
        </div>
      

     

     
</footer>
 
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="post-toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Mathf数学计算类常用方法"  data-scroll-to="#Mathf数学计算类常用方法"><span class="toc-text">Mathf数学计算类常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题"  data-scroll-to="#练习题"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#三角函数"  data-scroll-to="#三角函数"><span class="toc-text">三角函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结"  data-scroll-to="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-1"  data-scroll-to="#练习题-1"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#坐标系"  data-scroll-to="#坐标系"><span class="toc-text">坐标系</span></a></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Vector3向量模长和单位向量"  data-scroll-to="#Vector3向量模长和单位向量"><span class="toc-text">Vector3向量模长和单位向量</span></a></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#向量模长和单位向量-详解"  data-scroll-to="#向量模长和单位向量-详解"><span class="toc-text">向量模长和单位向量 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-1"  data-scroll-to="#总结-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#练习题-2"  data-scroll-to="#练习题-2"><span class="toc-text">练习题</span></a></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Vector3向量加减乘除"  data-scroll-to="#Vector3向量加减乘除"><span class="toc-text">Vector3向量加减乘除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#向量加减乘除-详解"  data-scroll-to="#向量加减乘除-详解"><span class="toc-text">向量加减乘除 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-3"  data-scroll-to="#练习题-3"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Vector3向量点乘"  data-scroll-to="#Vector3向量点乘"><span class="toc-text">Vector3向量点乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#向量点乘-详解"  data-scroll-to="#向量点乘-详解"><span class="toc-text">向量点乘 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#补充知识点-调试画线"  data-scroll-to="#补充知识点-调试画线"><span class="toc-text">补充知识点 调试画线</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-4"  data-scroll-to="#练习题-4"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Vector3向量叉乘"  data-scroll-to="#Vector3向量叉乘"><span class="toc-text">Vector3向量叉乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#向量叉乘-详解"  data-scroll-to="#向量叉乘-详解"><span class="toc-text">向量叉乘 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-2"  data-scroll-to="#总结-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-5"  data-scroll-to="#练习题-5"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Vector3向量差值运算"  data-scroll-to="#Vector3向量差值运算"><span class="toc-text">Vector3向量差值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#向量差值运算-详解"  data-scroll-to="#向量差值运算-详解"><span class="toc-text">向量差值运算 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-3"  data-scroll-to="#总结-3"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-6"  data-scroll-to="#练习题-6"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Quaternion四元数的使用原因"  data-scroll-to="#Quaternion四元数的使用原因"><span class="toc-text">Quaternion四元数的使用原因</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#四元数"  data-scroll-to="#四元数"><span class="toc-text">四元数</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Quaternion四元数是什么"  data-scroll-to="#Quaternion四元数是什么"><span class="toc-text">Quaternion四元数是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#TOOD补齐"  data-scroll-to="#TOOD补齐"><span class="toc-text">TOOD补齐</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Quaternion四元素常用方法"  data-scroll-to="#Quaternion四元素常用方法"><span class="toc-text">Quaternion四元素常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-4"  data-scroll-to="#总结-4"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-7"  data-scroll-to="#练习题-7"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Quaternion四元数计算"  data-scroll-to="#Quaternion四元数计算"><span class="toc-text">Quaternion四元数计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-8"  data-scroll-to="#练习题-8"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#延迟函数"  data-scroll-to="#延迟函数"><span class="toc-text">延迟函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#延迟函数-详解"  data-scroll-to="#延迟函数-详解"><span class="toc-text">延迟函数 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-5"  data-scroll-to="#总结-5"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-9"  data-scroll-to="#练习题-9"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#协同程序"  data-scroll-to="#协同程序"><span class="toc-text">协同程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-6"  data-scroll-to="#总结-6"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-10"  data-scroll-to="#练习题-10"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#协同程序原理"  data-scroll-to="#协同程序原理"><span class="toc-text">协同程序原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-7"  data-scroll-to="#总结-7"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-11"  data-scroll-to="#练习题-11"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Unity中的特殊文件夹"  data-scroll-to="#Unity中的特殊文件夹"><span class="toc-text">Unity中的特殊文件夹</span></a></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Resources同步加载"  data-scroll-to="#Resources同步加载"><span class="toc-text">Resources同步加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-8"  data-scroll-to="#总结-8"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-12"  data-scroll-to="#练习题-12"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Resources异步加载"  data-scroll-to="#Resources异步加载"><span class="toc-text">Resources异步加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-9"  data-scroll-to="#总结-9"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-13"  data-scroll-to="#练习题-13"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Resources卸载资源"  data-scroll-to="#Resources卸载资源"><span class="toc-text">Resources卸载资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-10"  data-scroll-to="#总结-10"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#场景异步加载"  data-scroll-to="#场景异步加载"><span class="toc-text">场景异步加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-11"  data-scroll-to="#总结-11"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-14"  data-scroll-to="#练习题-14"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#LineRenderer画线渲染器组件"  data-scroll-to="#LineRenderer画线渲染器组件"><span class="toc-text">LineRenderer画线渲染器组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#LineRenderer组件参数-详解"  data-scroll-to="#LineRenderer组件参数-详解"><span class="toc-text">LineRenderer组件参数 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#Linerenderer组件代码-详解"  data-scroll-to="#Linerenderer组件代码-详解"><span class="toc-text">Linerenderer组件代码 详解</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-15"  data-scroll-to="#练习题-15"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#范围检测"  data-scroll-to="#范围检测"><span class="toc-text">范围检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#总结-12"  data-scroll-to="#总结-12"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#练习题-16"  data-scroll-to="#练习题-16"><span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#射线检测"  data-scroll-to="#射线检测"><span class="toc-text">射线检测</span></a></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#练习题-17"  data-scroll-to="#练习题-17"><span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a rel="nofollow" class="toc-link" href="#TOOD"  data-scroll-to="#TOOD"><span class="toc-text">TOOD</span></a></li></ol></li><li class="toc-item toc-level-1"><a rel="nofollow" class="toc-link" href="#Unity基础知识总结"  data-scroll-to="#Unity基础知识总结"><span class="toc-text">Unity基础知识总结</span></a></li></ol>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="目录">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="阅读模式" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="单栏和双栏切换" onclick="asyncFun.switchSingleColumn()">
            <i class="iconfont fas fa-arrows-alt-h"></i>
        </div>
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="回到顶部">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    



<!-- CDN -->


    

    

    




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/Test.github.io/js/main.js?v=2.1.0-beta.2"></script>

</body>

</html>